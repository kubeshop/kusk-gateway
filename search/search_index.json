{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kusk Gateway Kusk Gateway is a self-service API gateway powered by OpenAPI and Envoy ! Kusk Gateway enables you to design and configure your APIs from single OpenAPI manifest and you can: Rapidly prototype your APIs by mocking your API responses, allowing your teams to instantly start building on top of your APIs without your services being implemented. Protect your endpoints with automatic request and response validations . Configure critical policies like request timeouts and CORs with no coding required . Centrally control your APIs from an Open Source dashboard. Kusk Gateway is for you if: You or your team develop REST APIs running in Kubernetes. You embrace a contract-first approach to developing your APIs using OpenAPI or Swagger. You want to ramp-up time when deploying a new REST api to a cluster and you don't want to spend lots of time configuring ingress controllers that require a dedicated Ops Engineer. You want your REST API endpoints traffic to be observable and controllable with the easy to use settings. Kusk Gateway has a unique way to the configuration among other API gateways as it configures itself through the metadata defined in your OpenAPI or Swagger document. You can apply your API definition like any other Kubernetes resource using our custom-made Kusk Gateway API CustomResourceDefinition (CRDs). Other Custom Resources are used to configure the Envoy Fleet which implements the gateway and specifies additional routing configurations. You can check the supported and planned features at Kusk Gateway Roadmap . Proceed with our Installation instructions for installing to the generic Kubernetes cluster Once you have Kusk Gateway installed, feel free to check out the Deploy an API section to get started with Kusk Gateway.","title":"Welcome"},{"location":"#kusk-gateway","text":"Kusk Gateway is a self-service API gateway powered by OpenAPI and Envoy ! Kusk Gateway enables you to design and configure your APIs from single OpenAPI manifest and you can: Rapidly prototype your APIs by mocking your API responses, allowing your teams to instantly start building on top of your APIs without your services being implemented. Protect your endpoints with automatic request and response validations . Configure critical policies like request timeouts and CORs with no coding required . Centrally control your APIs from an Open Source dashboard. Kusk Gateway is for you if: You or your team develop REST APIs running in Kubernetes. You embrace a contract-first approach to developing your APIs using OpenAPI or Swagger. You want to ramp-up time when deploying a new REST api to a cluster and you don't want to spend lots of time configuring ingress controllers that require a dedicated Ops Engineer. You want your REST API endpoints traffic to be observable and controllable with the easy to use settings. Kusk Gateway has a unique way to the configuration among other API gateways as it configures itself through the metadata defined in your OpenAPI or Swagger document. You can apply your API definition like any other Kubernetes resource using our custom-made Kusk Gateway API CustomResourceDefinition (CRDs). Other Custom Resources are used to configure the Envoy Fleet which implements the gateway and specifies additional routing configurations. You can check the supported and planned features at Kusk Gateway Roadmap . Proceed with our Installation instructions for installing to the generic Kubernetes cluster Once you have Kusk Gateway installed, feel free to check out the Deploy an API section to get started with Kusk Gateway.","title":"Kusk Gateway"},{"location":"privacy/","text":"Privacy Policy With the aim to improve the user experience, Kusk collects anonymous usage data. You may opt-out if you'd prefer not to share any information. The data collected is always anonymous, not traceable to the source, and only used in aggregate form. Telemetry collects and scrambles information about the host when the API server is bootstrapped for the first time. { \"anonymousId\" : \"37c7dd3d2f0cd7eca8fdc5b606577278bf2a65e5da42fd4b809cfdf103583a98\" , \"context\" : { \"library\" : { \"name\" : \"analytics-go\" , \"version\" : \"3.0.0\" } }, \"event\" : \"kusk-cli\" , \"integrations\" : {}, \"messageId\" : \"c785d086-2d85-4d7a-9468-1da350822c95\" , \"originalTimestamp\" : \"2022-07-15T11:42:41.213006+08:00\" , \"properties\" : { \"event\" : \"dashboard\" }, \"receivedAt\" : \"2022-07-15T03:42:42.691Z\" , \"sentAt\" : \"2022-07-15T03:42:41.215Z\" , \"timestamp\" : \"2022-07-15T03:42:42.689Z\" , \"type\" : \"track\" , \"userId\" : \"37c7dd3d2f0cd7eca8fdc5b606577278bf2a65e5da42fd4b809cfdf103583a98\" , \"writeKey\" : \"1t8VoI1wfqa43n0pYU01VZU2ZVDJKcQh\" } What We Collect The telemetry data we use in our metrics is limited to: The number of CLI installations. The number of unique CLI usages in a day. The number of installations to a cluster. The number of unique active cluster installations. The number of people who disable telemetry. The number of unique sessions in the UI. The number of API, StaticRoute and EnvoyFleet creations. How to opt out Helm Chart To disable sending the anonymous analytics, provide the analytics.enable: false override during Helm chart installation or upgrade. See the Helm chart parameters for more details about Helm chart configuration. helm upgrade kusk-gateway kubeshop/kusk-gateway \\ --install --namespace --create-namespace \\ --set analytics.enabled=false \\ ... Kusk CLI Set the following environment variable when running kusk commands export ANALYTICS_ENABLED=false or ANALYTICS_ENABLED=false kusk install","title":"Privacy Policy"},{"location":"privacy/#privacy-policy","text":"With the aim to improve the user experience, Kusk collects anonymous usage data. You may opt-out if you'd prefer not to share any information. The data collected is always anonymous, not traceable to the source, and only used in aggregate form. Telemetry collects and scrambles information about the host when the API server is bootstrapped for the first time. { \"anonymousId\" : \"37c7dd3d2f0cd7eca8fdc5b606577278bf2a65e5da42fd4b809cfdf103583a98\" , \"context\" : { \"library\" : { \"name\" : \"analytics-go\" , \"version\" : \"3.0.0\" } }, \"event\" : \"kusk-cli\" , \"integrations\" : {}, \"messageId\" : \"c785d086-2d85-4d7a-9468-1da350822c95\" , \"originalTimestamp\" : \"2022-07-15T11:42:41.213006+08:00\" , \"properties\" : { \"event\" : \"dashboard\" }, \"receivedAt\" : \"2022-07-15T03:42:42.691Z\" , \"sentAt\" : \"2022-07-15T03:42:41.215Z\" , \"timestamp\" : \"2022-07-15T03:42:42.689Z\" , \"type\" : \"track\" , \"userId\" : \"37c7dd3d2f0cd7eca8fdc5b606577278bf2a65e5da42fd4b809cfdf103583a98\" , \"writeKey\" : \"1t8VoI1wfqa43n0pYU01VZU2ZVDJKcQh\" }","title":"Privacy Policy"},{"location":"privacy/#what-we-collect","text":"The telemetry data we use in our metrics is limited to: The number of CLI installations. The number of unique CLI usages in a day. The number of installations to a cluster. The number of unique active cluster installations. The number of people who disable telemetry. The number of unique sessions in the UI. The number of API, StaticRoute and EnvoyFleet creations.","title":"What We Collect"},{"location":"privacy/#how-to-opt-out","text":"","title":"How to opt out"},{"location":"privacy/#helm-chart","text":"To disable sending the anonymous analytics, provide the analytics.enable: false override during Helm chart installation or upgrade. See the Helm chart parameters for more details about Helm chart configuration. helm upgrade kusk-gateway kubeshop/kusk-gateway \\ --install --namespace --create-namespace \\ --set analytics.enabled=false \\ ...","title":"Helm Chart"},{"location":"privacy/#kusk-cli","text":"Set the following environment variable when running kusk commands export ANALYTICS_ENABLED=false or ANALYTICS_ENABLED=false kusk install","title":"Kusk CLI"},{"location":"cli/dashboard-cmd/","text":"Accessing the Kusk Gateway Dashboard Kusk provides a kusk dashboard command to expose and navigate easily to the Kusk Gateway Dashboard in the browser. kusk dashboard will start a port-forward session on port 8080, by default, to the envoyfleet serving the dashboard and will open the dashboard in the browser. By default this is kusk-gateway-private-envoy-fleet.kusk-system. If you installed all the components using kusk install without changing any of the default values, running kusk dashboard will be sufficient to open the dashboard. The flags --envoyfleet.namespace and --envoyfleet.name can be used to change the envoyfleet. Flags Flag Description Required? --kubeconfig absolute path to kube config \u274c --envoyfleet.name kusk gateway dashboard envoy fleet service name. (default: kusk-gateway-private-envoy-fleet) \u274c --envoyfleet.namespace kusk gateway dashboard envoy fleet service namespace. (default: kusk-system) \u274c --external-port external port to access dashboard at. (default: 8080) \u274c Examples $ kusk dashboard Opens the kusk gateway dashboard in the browser by exposing the default private envoy fleet on port 8080 $ kusk dashboard --envoyfleet.namespace=other-namespace --envoyfleet.name=other-envoy-fleet Specify other envoyfleet and namespace that is serving the dashboard $ kusk dashboard --external-port=9090 Expose dashboard on port 9090 $ kusk dashboard --kubeconfig=/path/to/kube/config Specify path to kube config. $HOME/.kube/config is used by default.","title":"Accessing Kusk Gateway's Dashboard"},{"location":"cli/dashboard-cmd/#accessing-the-kusk-gateway-dashboard","text":"Kusk provides a kusk dashboard command to expose and navigate easily to the Kusk Gateway Dashboard in the browser. kusk dashboard will start a port-forward session on port 8080, by default, to the envoyfleet serving the dashboard and will open the dashboard in the browser. By default this is kusk-gateway-private-envoy-fleet.kusk-system. If you installed all the components using kusk install without changing any of the default values, running kusk dashboard will be sufficient to open the dashboard. The flags --envoyfleet.namespace and --envoyfleet.name can be used to change the envoyfleet.","title":"Accessing the Kusk Gateway Dashboard"},{"location":"cli/dashboard-cmd/#flags","text":"Flag Description Required? --kubeconfig absolute path to kube config \u274c --envoyfleet.name kusk gateway dashboard envoy fleet service name. (default: kusk-gateway-private-envoy-fleet) \u274c --envoyfleet.namespace kusk gateway dashboard envoy fleet service namespace. (default: kusk-system) \u274c --external-port external port to access dashboard at. (default: 8080) \u274c","title":"Flags"},{"location":"cli/dashboard-cmd/#examples","text":"$ kusk dashboard Opens the kusk gateway dashboard in the browser by exposing the default private envoy fleet on port 8080 $ kusk dashboard --envoyfleet.namespace=other-namespace --envoyfleet.name=other-envoy-fleet Specify other envoyfleet and namespace that is serving the dashboard $ kusk dashboard --external-port=9090 Expose dashboard on port 9090 $ kusk dashboard --kubeconfig=/path/to/kube/config Specify path to kube config. $HOME/.kube/config is used by default.","title":"Examples"},{"location":"cli/generate-cmd/","text":"Generating API CRDs The generate command accepts your OpenAPI definition as input, either as a local file or a URL pointing to your file and generates a Kusk Gateway compatible API resource that you can apply directly into your cluster. Use this command to automate API deployment workflows from an existing OpenAPI definition. Configuration of the API resource is done via the x-kusk extension. If the OpenAPI definition doesn't have a top-level x-kusk property set, it will add them for you and set the upstream service, namespace and port to the flag values passed, respectively, and set the rest of the settings to defaults. This is enough to get you started. If the x-kusk extension is already present, it will override the upstream service, namespace and port to the flag values passed, respectively, and leave the rest of the settings as they are. You must specify the name of the EnvoyFleet you wish to use to expose your API. Kusk Gateway could be managing more than one. In the future, we will add a default EnvoyFleet which Kusk Gateway will use when none is specified. i.e., kusk-gateway-envoy-fleet . If you do not specify the EnvoyFleet namespace, it will default to kusk-system . Usage No name specified: kusk api generate \\ -i spec.yaml \\ --envoyfleet.name kusk-gateway-envoy-fleet \\ --envoyfleet.namespace kusk-system In the above example, Kusk will use the OpenAPI definition info.title property to generate a manifest name and leave the existing x-kusk extension settings. No api namespace specified: kusk api generate \\ -i spec.yaml \\ --name httpbin-api \\ --upstream.service httpbin \\ --upstream.port 8080 \\ --envoyfleet.name kusk-gateway-envoy-fleet In the above example, as --namespace isn't defined, the default namespace will be used. Namespace specified: kusk api generate \\ -i spec.yaml \\ --name httpbin-api \\ --upstream.service httpbin \\ --upstream.namespace my-namespace \\ --upstream.port 8080 \\ --envoyfleet.name kusk-gateway-envoy-fleet OpenAPI definition from URL: kusk api generate \\ -i https://raw.githubusercontent.com/ $ORG_OR_USER / $REPO /myspec.yaml \\ --name httpbin-api \\ --upstream.service httpbin \\ --upstream.namespace my-namespace \\ --upstream.port 8080 \\ --envoyfleet.name kusk-gateway-envoy-fleet This will fetch the OpenAPI document from the provided URL and generate a Kusk Gateway API resource. Example Take a look at the http-bin example spec . kusk api generate -i ./examples/httpbin-spec.yaml --name httpbin-api --upstream.service httpbin --upstream.port 8080 --envoyfleet.name kusk-gateway-envoy-fleet The output should contain the following x-kusk extension at the top level: ... x-kusk: cors: {} path: rewrite: pattern: \"\" substitution: \"\" upstream: service: name: httpbin namespace: default port: 8080 Arguments Argument Description Required? --name The name to give the API resource e.g. --name my-api. Otherwise, taken from OpenAPI info title field. \u274c --namespace / -n The namespace of the API resource e.g. --namespace my-namespace, -n my-namespace (default: default). \u274c --in / -i The file path or URL to OpenAPI definition to generate mappings from. e.g. --in apispec.yaml. \u2705 --upstream.service The name of upstream Kubernetes service. \u274c --upstream.namespace The namespace of upstream service (default: default). \u274c --upstream.port The port that upstream service is exposed on (default: 80). \u274c --envoyfleet.name The name of envoyfleet to use for this API. \u2705 envoyfleet.namespace The namespace of envoyfleet to use for this API. Default: kusk-system. \u274c","title":"Generating API CRDs"},{"location":"cli/generate-cmd/#generating-api-crds","text":"The generate command accepts your OpenAPI definition as input, either as a local file or a URL pointing to your file and generates a Kusk Gateway compatible API resource that you can apply directly into your cluster. Use this command to automate API deployment workflows from an existing OpenAPI definition. Configuration of the API resource is done via the x-kusk extension. If the OpenAPI definition doesn't have a top-level x-kusk property set, it will add them for you and set the upstream service, namespace and port to the flag values passed, respectively, and set the rest of the settings to defaults. This is enough to get you started. If the x-kusk extension is already present, it will override the upstream service, namespace and port to the flag values passed, respectively, and leave the rest of the settings as they are. You must specify the name of the EnvoyFleet you wish to use to expose your API. Kusk Gateway could be managing more than one. In the future, we will add a default EnvoyFleet which Kusk Gateway will use when none is specified. i.e., kusk-gateway-envoy-fleet . If you do not specify the EnvoyFleet namespace, it will default to kusk-system .","title":"Generating API CRDs"},{"location":"cli/generate-cmd/#usage","text":"No name specified: kusk api generate \\ -i spec.yaml \\ --envoyfleet.name kusk-gateway-envoy-fleet \\ --envoyfleet.namespace kusk-system In the above example, Kusk will use the OpenAPI definition info.title property to generate a manifest name and leave the existing x-kusk extension settings. No api namespace specified: kusk api generate \\ -i spec.yaml \\ --name httpbin-api \\ --upstream.service httpbin \\ --upstream.port 8080 \\ --envoyfleet.name kusk-gateway-envoy-fleet In the above example, as --namespace isn't defined, the default namespace will be used. Namespace specified: kusk api generate \\ -i spec.yaml \\ --name httpbin-api \\ --upstream.service httpbin \\ --upstream.namespace my-namespace \\ --upstream.port 8080 \\ --envoyfleet.name kusk-gateway-envoy-fleet OpenAPI definition from URL: kusk api generate \\ -i https://raw.githubusercontent.com/ $ORG_OR_USER / $REPO /myspec.yaml \\ --name httpbin-api \\ --upstream.service httpbin \\ --upstream.namespace my-namespace \\ --upstream.port 8080 \\ --envoyfleet.name kusk-gateway-envoy-fleet This will fetch the OpenAPI document from the provided URL and generate a Kusk Gateway API resource.","title":"Usage"},{"location":"cli/generate-cmd/#example","text":"Take a look at the http-bin example spec . kusk api generate -i ./examples/httpbin-spec.yaml --name httpbin-api --upstream.service httpbin --upstream.port 8080 --envoyfleet.name kusk-gateway-envoy-fleet The output should contain the following x-kusk extension at the top level: ... x-kusk: cors: {} path: rewrite: pattern: \"\" substitution: \"\" upstream: service: name: httpbin namespace: default port: 8080","title":"Example"},{"location":"cli/generate-cmd/#arguments","text":"Argument Description Required? --name The name to give the API resource e.g. --name my-api. Otherwise, taken from OpenAPI info title field. \u274c --namespace / -n The namespace of the API resource e.g. --namespace my-namespace, -n my-namespace (default: default). \u274c --in / -i The file path or URL to OpenAPI definition to generate mappings from. e.g. --in apispec.yaml. \u2705 --upstream.service The name of upstream Kubernetes service. \u274c --upstream.namespace The namespace of upstream service (default: default). \u274c --upstream.port The port that upstream service is exposed on (default: 80). \u274c --envoyfleet.name The name of envoyfleet to use for this API. \u2705 envoyfleet.namespace The namespace of envoyfleet to use for this API. Default: kusk-system. \u274c","title":"Arguments"},{"location":"cli/install-cmd/","text":"Installing Kusk Gateway with the Kusk CLI The install command will install Kusk Gateway and all its components with a single command. Kusk uses Helm to do this, so you will need to have Helm installed . Kusk Gateway Components Kusk Gateway Manager - Responsible for updating and rolling out the Envoy configuration to your Envoy Fleets as you deploy APIs and Static Routes. Envoy Fleet - Responsible for exposing and routing to your APIs and frontends. Kusk Gateway API - REST API, which is exposed by Kusk Gateway and allows you to programmatically query which APIs, Static Routes and Envoy Fleets are deployed. Kusk Gateway Dashboard - A web UI for Kusk Gateway where you can deploy APIs and see which APIs, StaticRoutes and Envoy Fleets are deployed. Examples The default kusk install command will install Kusk Gateway, a public (for your APIs) and private (for the Kusk dashboard and API) envoy-fleet, api, and dashboard in the kusk-system namespace using Helm and using the current kubeconfig context. $ kusk install adding the kubeshop helm repository done fetching the latest charts done installing Kusk Gateway done installing Envoy Fleet done installing Kusk API done installing Kusk Dashboard done To access the dashboard, port forward to the envoy-fleet service that exposes it: $ kubectl port-forward -n kusk-system svc/kusk-gateway-private-envoy-fleet 8080 :80 Then go http://localhost:8080/ The following command will create a Helm release named with --name in the namespace specified by --namespace . $ kusk install --name = my-release --namespace = my-namespace ... The following command will install Kusk Gateway, but not the dashboard, api, or envoy-fleet. $ kusk install --no-dashboard --no-api --no-envoy-fleet ... Arguments Flag Description Required? --name The prefix of the name to give to the helm releases for each of the kusk gateway components (default: kusk-gateway). \u274c --namespace / -n The namespace to install kusk gateway into. Will create the namespace if it doesn't exist (default: kusk-system). \u274c --no-dashboard When set, will not install the kusk gateway dashboard. \u274c --no-api When set, will not install the kusk gateway api. implies --no-dashboard. \u274c --no-envoy-fleet When set, will not install any envoy fleets. \u274c Environment Variables To disable analytics set following environment variable: export ANALYTICS_ENABLED=false or run ANALYTICS_ENABLED=false kusk install","title":"Install Kusk Gateway"},{"location":"cli/install-cmd/#installing-kusk-gateway-with-the-kusk-cli","text":"The install command will install Kusk Gateway and all its components with a single command. Kusk uses Helm to do this, so you will need to have Helm installed .","title":"Installing Kusk Gateway with the Kusk CLI"},{"location":"cli/install-cmd/#kusk-gateway-components","text":"Kusk Gateway Manager - Responsible for updating and rolling out the Envoy configuration to your Envoy Fleets as you deploy APIs and Static Routes. Envoy Fleet - Responsible for exposing and routing to your APIs and frontends. Kusk Gateway API - REST API, which is exposed by Kusk Gateway and allows you to programmatically query which APIs, Static Routes and Envoy Fleets are deployed. Kusk Gateway Dashboard - A web UI for Kusk Gateway where you can deploy APIs and see which APIs, StaticRoutes and Envoy Fleets are deployed.","title":"Kusk Gateway Components"},{"location":"cli/install-cmd/#examples","text":"The default kusk install command will install Kusk Gateway, a public (for your APIs) and private (for the Kusk dashboard and API) envoy-fleet, api, and dashboard in the kusk-system namespace using Helm and using the current kubeconfig context. $ kusk install adding the kubeshop helm repository done fetching the latest charts done installing Kusk Gateway done installing Envoy Fleet done installing Kusk API done installing Kusk Dashboard done To access the dashboard, port forward to the envoy-fleet service that exposes it: $ kubectl port-forward -n kusk-system svc/kusk-gateway-private-envoy-fleet 8080 :80 Then go http://localhost:8080/ The following command will create a Helm release named with --name in the namespace specified by --namespace . $ kusk install --name = my-release --namespace = my-namespace ... The following command will install Kusk Gateway, but not the dashboard, api, or envoy-fleet. $ kusk install --no-dashboard --no-api --no-envoy-fleet ...","title":"Examples"},{"location":"cli/install-cmd/#arguments","text":"Flag Description Required? --name The prefix of the name to give to the helm releases for each of the kusk gateway components (default: kusk-gateway). \u274c --namespace / -n The namespace to install kusk gateway into. Will create the namespace if it doesn't exist (default: kusk-system). \u274c --no-dashboard When set, will not install the kusk gateway dashboard. \u274c --no-api When set, will not install the kusk gateway api. implies --no-dashboard. \u274c --no-envoy-fleet When set, will not install any envoy fleets. \u274c","title":"Arguments"},{"location":"cli/install-cmd/#environment-variables","text":"To disable analytics set following environment variable: export ANALYTICS_ENABLED=false or run ANALYTICS_ENABLED=false kusk install","title":"Environment Variables"},{"location":"cli/mock-cmd/","text":"Mock your API locally using Kusk Spin up a local mocking server that generates responses from your content schema or returns your defined examples. Kusk uses Docker to launch a mock server container. All you need to get started is your OpenAPI definition. Example Provide your API Let's mock the following API using Kusk. openapi : 3.0.0 info : title : todo-backend-api version : 0.0.2 paths : /todos : get : responses : '200' : description : 'ToDos' content : application/json : schema : type : object properties : title : type : string description : Description of what to do completed : type : boolean order : type : integer format : int32 url : type : string format : uri required : - title - completed - order - url application/xml : example : title : \"Mocked XML title\" completed : true order : 13 url : \"http://mockedURL.com\" text/plain : example : | title: \"Mocked Text title\" completed: true order: 13 url: \"http://mockedURL.com\" It has a single path with 3 content types. - application/json specifies a response schema which kusk will generate a generated response that matches - applications/xml and text/plain specifies examples which kusk will return as is. Launch Kusk Mocking Server $ kusk mock -i todo-backend-api.yaml \ud83c\udf89 successfully parsed OpenAPI spec \u2600\ufe0f initializing mocking server \ud83c\udf89 server successfully initialized URL: http://localhost:8080 \u23f3 watching for file changes in todo-backend-api.yaml The mock server is now running and will watch for any changes you make to fake todo-backend-api.yaml. Interacting with your API Let's curl the endpoint for a JSON response $ curl -H \"Accept: application/json\" localhost:8080/todos | jq { \"completed\" : true, \"order\" : 507256954 , \"title\" : \"Praesentium accusantium magni sequi saepe blanditiis. Officiis omnis sapiente laudantium quod. Vel dolorum voluptatibus sequi voluptatem voluptas nam.\" , \"url\" : \"http://sanfordconroy.name/elda.hills\" } The response returns matches the schema that we defined under the application/json content response. Let's now curl for application/xml and text/plain $ curl -H \"Accept: application/xml\" localhost:8080/todos <doc><completed>true</completed><order>13</order><title>Mocked XML title</title><url>http://mockedURL.com</url></doc> $ curl -H \"Accept: text/plain\" localhost:8080/todos title: \"Mocked Text title\" completed: true order: 13 url: \"http://mockedURL.com\" Here the examples defined above are returned. Kusk mock prioritises examples over schema definitions. Updating your API Let's change the name of route /todos to /foo . Note the file watcher doesn't pick up changes made in Vim - related issue . Use any other text editor to do this. openapi : 3.0.0 info : title : todo-backend-api version : 0.0.2 paths : /foo : ... ... \u270d\ufe0f change detected in fake-api.yaml \u2600\ufe0f mock server restarted When a change is detected, the server is restarted to serve the upto date api. Now we can curl the /foo endpoint as before. $ curl -H \"Accept: application/json\" localhost:8080/foo $ curl -H \"Accept: application/xml\" localhost:8080/foo $ curl -H \"Accept: text/plain\" localhost:8080/foo Stop the server ctrl+c","title":"Mocking your API"},{"location":"cli/mock-cmd/#mock-your-api-locally-using-kusk","text":"Spin up a local mocking server that generates responses from your content schema or returns your defined examples. Kusk uses Docker to launch a mock server container. All you need to get started is your OpenAPI definition.","title":"Mock your API locally using Kusk"},{"location":"cli/mock-cmd/#example","text":"","title":"Example"},{"location":"cli/mock-cmd/#provide-your-api","text":"Let's mock the following API using Kusk. openapi : 3.0.0 info : title : todo-backend-api version : 0.0.2 paths : /todos : get : responses : '200' : description : 'ToDos' content : application/json : schema : type : object properties : title : type : string description : Description of what to do completed : type : boolean order : type : integer format : int32 url : type : string format : uri required : - title - completed - order - url application/xml : example : title : \"Mocked XML title\" completed : true order : 13 url : \"http://mockedURL.com\" text/plain : example : | title: \"Mocked Text title\" completed: true order: 13 url: \"http://mockedURL.com\" It has a single path with 3 content types. - application/json specifies a response schema which kusk will generate a generated response that matches - applications/xml and text/plain specifies examples which kusk will return as is.","title":"Provide your API"},{"location":"cli/mock-cmd/#launch-kusk-mocking-server","text":"$ kusk mock -i todo-backend-api.yaml \ud83c\udf89 successfully parsed OpenAPI spec \u2600\ufe0f initializing mocking server \ud83c\udf89 server successfully initialized URL: http://localhost:8080 \u23f3 watching for file changes in todo-backend-api.yaml The mock server is now running and will watch for any changes you make to fake todo-backend-api.yaml.","title":"Launch Kusk Mocking Server"},{"location":"cli/mock-cmd/#interacting-with-your-api","text":"Let's curl the endpoint for a JSON response $ curl -H \"Accept: application/json\" localhost:8080/todos | jq { \"completed\" : true, \"order\" : 507256954 , \"title\" : \"Praesentium accusantium magni sequi saepe blanditiis. Officiis omnis sapiente laudantium quod. Vel dolorum voluptatibus sequi voluptatem voluptas nam.\" , \"url\" : \"http://sanfordconroy.name/elda.hills\" } The response returns matches the schema that we defined under the application/json content response. Let's now curl for application/xml and text/plain $ curl -H \"Accept: application/xml\" localhost:8080/todos <doc><completed>true</completed><order>13</order><title>Mocked XML title</title><url>http://mockedURL.com</url></doc> $ curl -H \"Accept: text/plain\" localhost:8080/todos title: \"Mocked Text title\" completed: true order: 13 url: \"http://mockedURL.com\" Here the examples defined above are returned. Kusk mock prioritises examples over schema definitions.","title":"Interacting with your API"},{"location":"cli/mock-cmd/#updating-your-api","text":"Let's change the name of route /todos to /foo . Note the file watcher doesn't pick up changes made in Vim - related issue . Use any other text editor to do this. openapi : 3.0.0 info : title : todo-backend-api version : 0.0.2 paths : /foo : ... ... \u270d\ufe0f change detected in fake-api.yaml \u2600\ufe0f mock server restarted When a change is detected, the server is restarted to serve the upto date api. Now we can curl the /foo endpoint as before. $ curl -H \"Accept: application/json\" localhost:8080/foo $ curl -H \"Accept: application/xml\" localhost:8080/foo $ curl -H \"Accept: text/plain\" localhost:8080/foo","title":"Updating your API"},{"location":"cli/mock-cmd/#stop-the-server","text":"ctrl+c","title":"Stop the server"},{"location":"cli/overview/","text":"Kusk CLI Kusk is a CLI tool designed to help you manage common tasks related to Kusk Gateway. The CLI supports the following commands: install - Installs Kusk Gateway and all its components with a single command - Read more . api generate - Generates Kusk Gateway API resources from OpenAPI - Read more . Installation Homebrew brew install kubeshop/kusk/kusk Using Golang Installation go install github.com/kubeshop/kusk@latest To install a particular version replace latest with the version number. You can get a list of the available Kusk Gateway versions from our releases page . Install Script Install kusk into /usr/local/bin/kusk : bash < < ( curl -sSLf https://raw.githubusercontent.com/kubeshop/kusk/main/scripts/install.sh ) From Source git clone git@github.com:kubeshop/kusk.git && \\ cd kusk && \\ go install Alternative Installation Method - Manual If you don't like automatic scripts you can install the CLI manually: Download binary with version of your choice (recent one is recommended). Upack it (tar -zxvf kusk_0.1.0_Linux_arm64.tar.gz). Move it to a location in the PATH. For example mv kusk_0.1.0_Linux_arm64/kusk /usr/local/bin/kusk . For Windows, download the binary from here , unpack the binary and add it to %PATH% . Updating Homebrew brew upgrade kubeshop/kusk/kusk Latest Release on GitHub go install github.com/kubeshop/kusk@$VERSION From Source Inside of the kusk repository directory: git clone https://github.com/kubeshop/kusk.git","title":"Installation"},{"location":"cli/overview/#kusk-cli","text":"Kusk is a CLI tool designed to help you manage common tasks related to Kusk Gateway. The CLI supports the following commands: install - Installs Kusk Gateway and all its components with a single command - Read more . api generate - Generates Kusk Gateway API resources from OpenAPI - Read more .","title":"Kusk CLI"},{"location":"cli/overview/#installation","text":"","title":"Installation"},{"location":"cli/overview/#homebrew","text":"brew install kubeshop/kusk/kusk","title":"Homebrew"},{"location":"cli/overview/#using-golang-installation","text":"go install github.com/kubeshop/kusk@latest To install a particular version replace latest with the version number. You can get a list of the available Kusk Gateway versions from our releases page .","title":"Using Golang Installation"},{"location":"cli/overview/#install-script","text":"Install kusk into /usr/local/bin/kusk : bash < < ( curl -sSLf https://raw.githubusercontent.com/kubeshop/kusk/main/scripts/install.sh )","title":"Install Script"},{"location":"cli/overview/#from-source","text":"git clone git@github.com:kubeshop/kusk.git && \\ cd kusk && \\ go install","title":"From Source"},{"location":"cli/overview/#alternative-installation-method-manual","text":"If you don't like automatic scripts you can install the CLI manually: Download binary with version of your choice (recent one is recommended). Upack it (tar -zxvf kusk_0.1.0_Linux_arm64.tar.gz). Move it to a location in the PATH. For example mv kusk_0.1.0_Linux_arm64/kusk /usr/local/bin/kusk . For Windows, download the binary from here , unpack the binary and add it to %PATH% .","title":"Alternative Installation Method - Manual"},{"location":"cli/overview/#updating","text":"","title":"Updating"},{"location":"cli/overview/#homebrew_1","text":"brew upgrade kubeshop/kusk/kusk","title":"Homebrew"},{"location":"cli/overview/#latest-release-on-github","text":"go install github.com/kubeshop/kusk@$VERSION","title":"Latest Release on GitHub"},{"location":"cli/overview/#from-source_1","text":"Inside of the kusk repository directory: git clone https://github.com/kubeshop/kusk.git","title":"From Source"},{"location":"contributing/development/","text":"How to Develop Kusk Gateway Kusk Gateway code is managed with the help of Kubebuilder that provides code scaffolding and generation of K8s Custom Resource Definitions files. Internally, Kusk Gateway uses the go-control-plane package to configure Envoy with its xDS protocol. Code Structure to Get Started with Development Below is the (reduced) output of the tree command on this repository. These are the directories and packages that we suggest you need to know about to get started with Kusk Gateway development. Obviously, there are more, so feel free to investigate the others for yourself to get an idea about how they fit into the overall architecture. kusk-gateway \u251c\u2500\u2500 api \u2502 \u2514\u2500\u2500 v1alpha1 # Our Custom CRD types in Go \u251c\u2500\u2500 build # Dockerfiles for the Manager and Agent processes \u2502 \u251c\u2500\u2500 agent \u2502 \u2514\u2500\u2500 manager \u251c\u2500\u2500 cmd # Entry point for the Manager and Agent processes \u2502 \u251c\u2500\u2500 agent \u2502 \u2514\u2500\u2500 manager \u251c\u2500\u2500 examples # Various example applications to test against \u2502 \u251c\u2500\u2500 httpbin \u2502 \u251c\u2500\u2500 todomvc \u2502 \u2502 \u2514\u2500\u2500 spec \u2502 \u2514\u2500\u2500 websocket \u251c\u2500\u2500 internal \u2502 \u251c\u2500\u2500 agent # Business Logic for the agent process which handles mocking API resposes \u2502 \u2502 \u251c\u2500\u2500 httpserver \u2502 \u2502 \u251c\u2500\u2500 management \u2502 \u2502 \u2514\u2500\u2500 mocking \u2502 \u251c\u2500\u2500 controllers # Custom Kubernetes controllers that handle CRD events \u2502 \u251c\u2500\u2500 envoy # Envoy configuration, go-control-plane manager set up, and the types we manage when building the config \u2502 \u2502 \u251c\u2500\u2500 config \u2502 \u2502 \u251c\u2500\u2500 manager \u2502 \u2502 \u2514\u2500\u2500 types \u2502 \u251c\u2500\u2500 k8sutils # useful helper functions for interacting with Kubernetes \u2502 \u251c\u2500\u2500 validation # Service proxy that handles request validation before forwarding the request onto the destination service \u2502 \u2514\u2500\u2500 webhooks # Create certs for the webhooks \u2514\u2500\u2500 pkg \u251c\u2500\u2500 analytics # Code for sending analytics data to telemetry provider \u251c\u2500\u2500 options # Options structs that contain the fields that the user will configure with the x-kusk extension in their OpenAPI definition \u2514\u2500\u2500 spec # Code for loading, parsing and validating the OpenAPI definition and the extensions. Set Up Development Environment You can install Kusk Gateway into any cluster offering. So you can BYOC (Bring Your Own Cluster). Launch Kusk Gateway in Minikube We have a useful Make command to set up a complete environment for development in Minikube. To set up the environment, run the following command: make create-env This will do the following: Start minikube with the profile name \"kusk\" and enable the Metallb add on. Metallb will expose the Envoy Fleet services \"locally\" without needing to port-forward to them. Install our CustomResourceDefinitions. Build the docker images, cache them for faster rebuilds and deploy them with Kustomize. Deploy an Envoy Fleet. Launch Kusk Gateway in Your Cluster If you opt to use a cluster offering that is not Minikube, you can use the following commands to launch Kusk Gateway in your cluster: # Install the CustomResourceDefinitions make install # Build and deploy the containers using Kustomize make docker-images-cache docker-build deploy # wait for rollout to complete kubectl rollout status -w deployment/kusk-gateway-manager -n kusk-system # Deploy EnvoyFleet make deploy-envoyfleet Redeploy After Code Changes The simplest way to ensure the recompliation of everything required is to run one of the following commands: # generate will recompile any controller implementations # manifest will regenerate WebhookConfiguration, ClusterRole and CustomResourceDefinition objects that may need updating # install will install the most recent versions of the CRDs # docker-build will rebuild the docker images # deploy will deploy the most recent versions of the containers # cycle will cycle the Kubernetes deployments to make sure they are running the most recent built versions make generate manifests install docker-build deploy cycle","title":"Development"},{"location":"contributing/development/#how-to-develop-kusk-gateway","text":"Kusk Gateway code is managed with the help of Kubebuilder that provides code scaffolding and generation of K8s Custom Resource Definitions files. Internally, Kusk Gateway uses the go-control-plane package to configure Envoy with its xDS protocol.","title":"How to Develop Kusk Gateway"},{"location":"contributing/development/#code-structure-to-get-started-with-development","text":"Below is the (reduced) output of the tree command on this repository. These are the directories and packages that we suggest you need to know about to get started with Kusk Gateway development. Obviously, there are more, so feel free to investigate the others for yourself to get an idea about how they fit into the overall architecture. kusk-gateway \u251c\u2500\u2500 api \u2502 \u2514\u2500\u2500 v1alpha1 # Our Custom CRD types in Go \u251c\u2500\u2500 build # Dockerfiles for the Manager and Agent processes \u2502 \u251c\u2500\u2500 agent \u2502 \u2514\u2500\u2500 manager \u251c\u2500\u2500 cmd # Entry point for the Manager and Agent processes \u2502 \u251c\u2500\u2500 agent \u2502 \u2514\u2500\u2500 manager \u251c\u2500\u2500 examples # Various example applications to test against \u2502 \u251c\u2500\u2500 httpbin \u2502 \u251c\u2500\u2500 todomvc \u2502 \u2502 \u2514\u2500\u2500 spec \u2502 \u2514\u2500\u2500 websocket \u251c\u2500\u2500 internal \u2502 \u251c\u2500\u2500 agent # Business Logic for the agent process which handles mocking API resposes \u2502 \u2502 \u251c\u2500\u2500 httpserver \u2502 \u2502 \u251c\u2500\u2500 management \u2502 \u2502 \u2514\u2500\u2500 mocking \u2502 \u251c\u2500\u2500 controllers # Custom Kubernetes controllers that handle CRD events \u2502 \u251c\u2500\u2500 envoy # Envoy configuration, go-control-plane manager set up, and the types we manage when building the config \u2502 \u2502 \u251c\u2500\u2500 config \u2502 \u2502 \u251c\u2500\u2500 manager \u2502 \u2502 \u2514\u2500\u2500 types \u2502 \u251c\u2500\u2500 k8sutils # useful helper functions for interacting with Kubernetes \u2502 \u251c\u2500\u2500 validation # Service proxy that handles request validation before forwarding the request onto the destination service \u2502 \u2514\u2500\u2500 webhooks # Create certs for the webhooks \u2514\u2500\u2500 pkg \u251c\u2500\u2500 analytics # Code for sending analytics data to telemetry provider \u251c\u2500\u2500 options # Options structs that contain the fields that the user will configure with the x-kusk extension in their OpenAPI definition \u2514\u2500\u2500 spec # Code for loading, parsing and validating the OpenAPI definition and the extensions.","title":"Code Structure to Get Started with Development"},{"location":"contributing/development/#set-up-development-environment","text":"You can install Kusk Gateway into any cluster offering. So you can BYOC (Bring Your Own Cluster).","title":"Set Up Development Environment"},{"location":"contributing/development/#launch-kusk-gateway-in-minikube","text":"We have a useful Make command to set up a complete environment for development in Minikube. To set up the environment, run the following command: make create-env This will do the following: Start minikube with the profile name \"kusk\" and enable the Metallb add on. Metallb will expose the Envoy Fleet services \"locally\" without needing to port-forward to them. Install our CustomResourceDefinitions. Build the docker images, cache them for faster rebuilds and deploy them with Kustomize. Deploy an Envoy Fleet.","title":"Launch Kusk Gateway in Minikube"},{"location":"contributing/development/#launch-kusk-gateway-in-your-cluster","text":"If you opt to use a cluster offering that is not Minikube, you can use the following commands to launch Kusk Gateway in your cluster: # Install the CustomResourceDefinitions make install # Build and deploy the containers using Kustomize make docker-images-cache docker-build deploy # wait for rollout to complete kubectl rollout status -w deployment/kusk-gateway-manager -n kusk-system # Deploy EnvoyFleet make deploy-envoyfleet","title":"Launch Kusk Gateway in Your Cluster"},{"location":"contributing/development/#redeploy-after-code-changes","text":"The simplest way to ensure the recompliation of everything required is to run one of the following commands: # generate will recompile any controller implementations # manifest will regenerate WebhookConfiguration, ClusterRole and CustomResourceDefinition objects that may need updating # install will install the most recent versions of the CRDs # docker-build will rebuild the docker images # deploy will deploy the most recent versions of the containers # cycle will cycle the Kubernetes deployments to make sure they are running the most recent built versions make generate manifests install docker-build deploy cycle","title":"Redeploy After Code Changes"},{"location":"contributing/roadmap/","text":"Supported and Planned Features The table below contains the current state of the Kusk Gateway features. Features marked with the \u2705 are implemented, not marked are planned to be implemented. For the features currently on the roadmap please see Kusk-gateway milestones . .tg { border-collapse: collapse; border-spacing: 0; } .tg td { border-color: black; border-style: solid; border-width: 1px; font-family: Arial, sans-serif; font-size: 14px; overflow: hidden; padding: 10px 5px; word-break: normal; } .tg th { border-color: black; border-style: solid; border-width: 1px; font-family: Arial, sans-serif; font-size: 14px; font-weight: normal; text-align: center; overflow: hidden; padding: 10px 5px; word-break: normal; } .tg .tg-0pky { border-color: inherit; text-align: left; vertical-align: top } Categories Feature/Description with the implementation status Comments Basic routing Configure the routing by: host \u2705 exact path \u2705 path with a regexp \u2705 path with a prefix \u2705 Basic routing with OpenAPI Configure the basic routing with OpenAPI + x-kusk extension \u2705 HTTP redirect HTTP redirect support, with dynamic path rewrites \u2705 Direct HTTP response Respond with HTTP code without sending to the upstream HTTP path manipulation Prepend and strip HTTP path prefix for the OpenAPI paths \u2705 Rewrite paths when sending to the upstream (backend) \u2705 HTTP sticky sessions Binding the client session to the same upstream host by IP address HTTP headers manipulation Inserting/removing headers when communicating with the upstream HTTP Compression Gzip/Bzip/Brotli headers/body compression TLS Static (externally deployed) certificates \u2705 LetsEncrypt (ACME) dynamically configured certificates CORS CORS support \u2705 Websockets Websockets support \u2705 Quality of the service Retries on 50x code \u2705 Request timeouts, idle timeouts \u2705 Rate limiting Cirquit breaker \u200b Advanced routing Traffic mirroring (sending the requests both to the actual upstream and mirror to some other sink, e.g. staging) Traffic splitting (sending to 2 or more services at the same time) Validation Validation of requests and responses using OpenAPI definition Partially: the validation of requests are in alpha mode Mocking Mocking endpoints using OpenAPI definition Visibility: Dashboard User friendly management portal Visibility: Logging Ability to collect, aggregate and analyze access and gateway logs Partially: enabled stdout access logging that can be used by third party tools like Fluentd. Visibility: Tracing Ability to trigger requests tracing Visibility: Metrics Ability to collect and analyze traffic and gateway metrics Partially: basic HTTP requests Prometheus metrics could be collected from Envoy Authentication Authentication schemes support with OpenAPI security and separately in StaticRoute","title":"Roadmap"},{"location":"contributing/roadmap/#supported-and-planned-features","text":"The table below contains the current state of the Kusk Gateway features. Features marked with the \u2705 are implemented, not marked are planned to be implemented. For the features currently on the roadmap please see Kusk-gateway milestones . .tg { border-collapse: collapse; border-spacing: 0; } .tg td { border-color: black; border-style: solid; border-width: 1px; font-family: Arial, sans-serif; font-size: 14px; overflow: hidden; padding: 10px 5px; word-break: normal; } .tg th { border-color: black; border-style: solid; border-width: 1px; font-family: Arial, sans-serif; font-size: 14px; font-weight: normal; text-align: center; overflow: hidden; padding: 10px 5px; word-break: normal; } .tg .tg-0pky { border-color: inherit; text-align: left; vertical-align: top } Categories Feature/Description with the implementation status Comments Basic routing Configure the routing by: host \u2705 exact path \u2705 path with a regexp \u2705 path with a prefix \u2705 Basic routing with OpenAPI Configure the basic routing with OpenAPI + x-kusk extension \u2705 HTTP redirect HTTP redirect support, with dynamic path rewrites \u2705 Direct HTTP response Respond with HTTP code without sending to the upstream HTTP path manipulation Prepend and strip HTTP path prefix for the OpenAPI paths \u2705 Rewrite paths when sending to the upstream (backend) \u2705 HTTP sticky sessions Binding the client session to the same upstream host by IP address HTTP headers manipulation Inserting/removing headers when communicating with the upstream HTTP Compression Gzip/Bzip/Brotli headers/body compression TLS Static (externally deployed) certificates \u2705 LetsEncrypt (ACME) dynamically configured certificates CORS CORS support \u2705 Websockets Websockets support \u2705 Quality of the service Retries on 50x code \u2705 Request timeouts, idle timeouts \u2705 Rate limiting Cirquit breaker \u200b Advanced routing Traffic mirroring (sending the requests both to the actual upstream and mirror to some other sink, e.g. staging) Traffic splitting (sending to 2 or more services at the same time) Validation Validation of requests and responses using OpenAPI definition Partially: the validation of requests are in alpha mode Mocking Mocking endpoints using OpenAPI definition Visibility: Dashboard User friendly management portal Visibility: Logging Ability to collect, aggregate and analyze access and gateway logs Partially: enabled stdout access logging that can be used by third party tools like Fluentd. Visibility: Tracing Ability to trigger requests tracing Visibility: Metrics Ability to collect and analyze traffic and gateway metrics Partially: basic HTTP requests Prometheus metrics could be collected from Envoy Authentication Authentication schemes support with OpenAPI security and separately in StaticRoute","title":"Supported and Planned Features"},{"location":"customresources/api/","text":"API This resource uses an OpenAPI file with x-kusk annotations as the source of truth to configure routing. Refer to OpenAPI Extension Reference for the further information on how to add routing information to OpenAPI file. The required field of API resource is spec.**spec** where x-kusk -enhanced OpenAPI file is supplied as an embedded string. You can generate API resources from an OpenAPI definition (and integrate into your CI) using the Kusk CLI - see Generating API CRDs . Using fleet The optional spec. fleet field specifies to what Envoy Fleet (Envoy Proxy instances with the exposing K8s Service) this configuration applies. The fleet. name and fleet. namespace fields reference the deployed Envoy Fleet Custom Resource name and namespace. Deploy your API configuration in any namespace with any name and it will be applied to the specific Envoy Fleet. If this option is missing, auto-detection will be performed to find the single fleet deployed in the Kubernetes cluster fleet, which is considered as the default fleet. The deployed API custom resource will be changed to map to that fleet accordingly. If there are multiple fleets deployed, the spec. fleet is required to specify in the manifest. Once the resource manifest is deployed, Kusk Gateway Manager will use it to configure routing for Envoy Fleet. Multiple resources can exist in different namespaces; all of them will be evaluated and the configuration merged on any update with these resources. Trying to apply a resource that has conflicting routes with the existing resources (i.e. same HTTP method and path) will result in error. Limitations Currently, the resource status field is not updated by the manager when the configuration process finishes. Example: apiVersion : gateway.kusk.io/v1alpha1 kind : API metadata : name : api-sample spec : # Envoy Fleet (its name and namespace) to deploy the configuration to, here - deployed EnvoyFleet with the name \"default\" in the namespace \"default\". # Optional, if not specified - single (default) fleet auto-detection will be performed in the cluster. fleet : name : default namespace : default # OpenAPI file with x-kusk annotation here spec : | openapi: 3.0.2 servers: - url: /api/v3 info: description: Some description version: 1.0.0 title: the best API in the world # top level x-kusk extension to configure routes x-kusk: disabled: false hosts: [ \"*\" ] cors: origins: - \"*\" methods: - POST - GET - OPTIONS headers: - Content-Type credentials: true expose_headers: - X-Custom-Header1 max_age: 86200 upstream: service: name: oldapi namespace: default port: 80 # Strips prefix when forwarding to upstream rewrite: pattern: \"^/api\" substitution: \"\" path: prefix: /api paths: /pet: x-kusk: disabled: true post: x-kusk: disabled: false upstream: host: hostname: newapi.default.svc.cluster.local port: 8080 --- skipped --- put: summary: Update pet description: Update an existing pet by Id operationId: updatePet --- skipped ---","title":"API"},{"location":"customresources/api/#api","text":"This resource uses an OpenAPI file with x-kusk annotations as the source of truth to configure routing. Refer to OpenAPI Extension Reference for the further information on how to add routing information to OpenAPI file. The required field of API resource is spec.**spec** where x-kusk -enhanced OpenAPI file is supplied as an embedded string. You can generate API resources from an OpenAPI definition (and integrate into your CI) using the Kusk CLI - see Generating API CRDs .","title":"API"},{"location":"customresources/api/#using-fleet","text":"The optional spec. fleet field specifies to what Envoy Fleet (Envoy Proxy instances with the exposing K8s Service) this configuration applies. The fleet. name and fleet. namespace fields reference the deployed Envoy Fleet Custom Resource name and namespace. Deploy your API configuration in any namespace with any name and it will be applied to the specific Envoy Fleet. If this option is missing, auto-detection will be performed to find the single fleet deployed in the Kubernetes cluster fleet, which is considered as the default fleet. The deployed API custom resource will be changed to map to that fleet accordingly. If there are multiple fleets deployed, the spec. fleet is required to specify in the manifest. Once the resource manifest is deployed, Kusk Gateway Manager will use it to configure routing for Envoy Fleet. Multiple resources can exist in different namespaces; all of them will be evaluated and the configuration merged on any update with these resources. Trying to apply a resource that has conflicting routes with the existing resources (i.e. same HTTP method and path) will result in error.","title":"Using fleet"},{"location":"customresources/api/#limitations","text":"Currently, the resource status field is not updated by the manager when the configuration process finishes. Example: apiVersion : gateway.kusk.io/v1alpha1 kind : API metadata : name : api-sample spec : # Envoy Fleet (its name and namespace) to deploy the configuration to, here - deployed EnvoyFleet with the name \"default\" in the namespace \"default\". # Optional, if not specified - single (default) fleet auto-detection will be performed in the cluster. fleet : name : default namespace : default # OpenAPI file with x-kusk annotation here spec : | openapi: 3.0.2 servers: - url: /api/v3 info: description: Some description version: 1.0.0 title: the best API in the world # top level x-kusk extension to configure routes x-kusk: disabled: false hosts: [ \"*\" ] cors: origins: - \"*\" methods: - POST - GET - OPTIONS headers: - Content-Type credentials: true expose_headers: - X-Custom-Header1 max_age: 86200 upstream: service: name: oldapi namespace: default port: 80 # Strips prefix when forwarding to upstream rewrite: pattern: \"^/api\" substitution: \"\" path: prefix: /api paths: /pet: x-kusk: disabled: true post: x-kusk: disabled: false upstream: host: hostname: newapi.default.svc.cluster.local port: 8080 --- skipped --- put: summary: Update pet description: Update an existing pet by Id operationId: updatePet --- skipped ---","title":"Limitations"},{"location":"customresources/envoyfleet/","text":"Envoy Fleet This resource defines the Envoy Fleet, which is the implementation of the gateway in Kubernetes based on Envoy Proxy. Once the resource manifest is deployed to Kubernetes, it is used by Kusk Gateway Manager to set up K8s Envoy Proxy Deployment , ConfigMap and Service . The ConfigMap config bootstraps Envoy Proxy to connect to the XDS service of the KGW Manager to retrieve the configuration. In its initial state there is a minimal configuration, you have to deploy API or StaticRoute resource to set up the routing. If the Custom Resource is uninstalled, the Manager deletes the created K8s resources. You can deploy multiple Envoy Fleets and have multiple Gateways available. Once the Fleet is deployed, its status field shows the success of the process (Deployed, Failed), so it can be shown with kubectl describe envoyfleet command. Limitations Currently, only the success of K8s resources deployment is shown, not if the Envoy Proxy pods are alive or if the Service has the External IP Address allocated. Supported parameters: metadata. name and metadata. namespace - Used as the Envoy Fleet ID. The Manager will supply the configuration for this specific ID - Envoy will connect to the KGW Manager with it. API/Static Route can be deployed to this fleet using their fleet name field. spec. image - The Envoy Proxy container image tag, usually envoyproxy/envoy-alpine. spec. service - Defines the configuration of the K8s Service that exposes the Envoy Proxy deployment. It is similar to the K8s Service configuration but with a limited set of fields. spec.service. type - Select the Service Type (NodePort, ClusterIP, LoadBalancer). spec.service. ports - Expose TCP ports (80, 443 or any other) routed to the ports names that Deployment exposes (http, https); ports to which the Envoy Proxy listener binds. spec.service. annotations - Add annotations to the Service that will control load balancer configuration in the specific cloud providers implementations (e.g. to set up the internal Google Cloud Platform load balancer in the Google Cloud Engine, we annotate Service with the related annotation). spec.service. loadBalancerIP - Used to specify the pre-allocated Load Balancer IP address so it won't be deleted in case the Service is deleted. spec.service. externalTrafficPolicy - Optional parameter that denotes if this Service routes external traffic to node-local or cluster-wide endpoints. Local preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. Cluster obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading. For the preservation of the real client IP in access logs, choose \"Local\" spec. size - Optional parameter to specify the number of Envoy Proxy pods in the K8s deployment. If not specified, defaults to 1. spec. resources - Optional parameter that configures the Envoy Proxy container CPU/Memory requests and limits. Read Resource Management for Pods and Containers for the details. By default, no requests or limits are specified. spec. annotations - Optional parameter that adds additional annotations to the Envoy Proxy pods, e.g. for Prometheus scraping. spec. nodeSelector , spec. tolerations and spec. affinity - Optional parameters that provide the Envoy Proxy deployment settings for the K8s Pod scheduler. Read Assigning Pods to Nodes to understand how can you bind Envoy pods to some types of nodes (e.g. non-preemtible node type pool) and how to ensure that Envoy pods are placed onto the different nodes for High Availability. See the YAML example below, too. The structure of these fields are the same as for K8s Deployment. These options can be used simultaneously, influencing each other. spec. accesslog - Optional parameter that defines Envoy Proxy stdout HTTP requests logging. Each Envoy pod can stream the access log to stdout. If not specified, no streaming occurs. If specified, you must chose the format and, optionally, the text or JSON template to tune the output. spec.accesslog. format - Required parameter that specifies the format of the output: JSON (structured) or text . Note that JSON format doesn't preserve fields order. spec.accesslog. text_template | json_template - Optional parameters that could be used to specify the exact Envoy request data to log. See Envoy's Access Logging for the details. If not specified, Kusk Gateway provided defaults. spec. tls - Optional parameter that defines TLS settings for the Envoy Fleet. If not specified, the Envoy Fleet will accept only HTTP traffic. spec.tls. cipherSuites - An optional field that, when specified, the TLS listener will only support the specified cipher list when negotiating TLS 1.0 or 1.2 (this setting has no effect when negotiating TLS 1.3). If not specified, a default list will be used. Defaults are different for server (downstream) and client (upstream) TLS configurations. For more information see: Envoy's Common TLS Configuration . spec.tls. tlsMinimumProtocolVersion - An optional field specifying the minimum TLS protocol version. By default, TLSv1_2 for clients and TLSv1_0 for servers. spec.tls. tlsMaximumProtocolVersion - An optional field specifying the maximum TLS protocol version. By default, TLSv1_2 for clients and TLSv1_3 for servers. spec.tls. https_redirect_hosts - An optional field specifying the domain names to force use of HTTPS with. Non-secure HTTP requests with the matched Host header will be automatically redirected to secure HTTPS with the \"301 Moved Permanently\" code. spec.tls. tlsSecrets - Secret name and namespace combinations for locating TLS secrets containing TLS certificates. More than one may be specified. Kusk Gateway Manager pulls the certificates from the secrets, extracts the matching hostnames from the SubjectAlternativeNames (SAN) certificate field and configures Envoy to use that certificate for those hostnames. spec.tls.tlsSecrets. secretRef - The name of the Kubernetes secret containing the TLS certificate. spec.tls.tlsSecrets. namespace - The namespace where the Kubernetes secret resides. apiVersion : gateway.kusk.io/v1alpha1 kind : EnvoyFleet metadata : name : default namespace : default spec : image : \"envoyproxy/envoy-alpine:v1.20.0\" service : # NodePort, ClusterIP, LoadBalancer type : LoadBalancer # Specify annotations to modify service behaviour, e.g. for GCP to create internal load balancer: # annotations: # networking.gke.io/load-balancer-type: \"Internal\" # Specify preallocated static load balancer IP address if present #loadBalancerIP: 10.10.10.10 ports : - name : http port : 80 targetPort : http - name : https port : 443 targetPort : http # externalTrafficPolicy: Cluster|Local resources : # limits: # cpu: 1 # memory: 100M requests : cpu : 10m memory : 100M # Put any additional annotations to the Enovy pod. # Here we add the annotations for the Prometheus service discovery to scrape Envoy pods for the Prometheus metrics. # annotations: # prometheus.io/scrape: 'true' # prometheus.io/port: '19000' # prometheus.io/path: /stats/prometheus ##### Scheduling directives # Read https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/ for the details. # Optional - schedule Envoy pods to the node with the label \"disktype=ssd\". # nodeSelector: # disktype: \"ssd\" # Optional - allow to be scheduled on the \"tainted\" node. Taint with \"kubectl taint nodes node1 key1=value1:NoSchedule\". # Taints will repel the pods from the node unless the pods have the specific toleration. # The line below will allow this specific Envoy pod to be scheduled there (but scheduler decideds where to put it anyway). # tolerations: # - key: \"key1\" # operator: \"Exists\" # effect: \"NoSchedule\" # Optional - provide pods affinity and anti-affinity settings. # This is more flexible than nodeSelector scheme, but they can be specified together. # For the scalability and fault tolerance we prefer to put all Envoy pods onto different nodes - in a case one node fails we survive on others. # The block below will search for all matching labels of THIS \"default\" envoy fleet pods and will try to schedule pods onto different nodes. # Other fleets (if present) are not taken into consideration. You can specify nodeAffinity and podAffinity as well. # affinity: # podAntiAffinity: # requiredDuringSchedulingIgnoredDuringExecution: # - labelSelector: # matchExpressions: # - key: app.kubernetes.io/name # operator: In # values: # - kusk-gateway-envoy-fleet # - key: fleet # operator: In # values: # - default # topologyKey: kubernetes.io/hostname # optional, the number of Envoy Proxy pods to start size : 1 # Access logging to stdout # Optional, if this is missing no access logging to stdout will be done accesslog : # json|text format : text # Depending on format we can specify our own log template or if template is not specified - default Kusk Gateway will be used. # See https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#config-access-log-format-strings for the details. # Below are specified the examples of similar and minimalistic formats for both text and json format types. # Text format fields order is preserved. # The output example: # \"[2021-12-15T16:50:50.217Z]\" \"GET\" \"/\" \"200\" \"1\" text_template : | \"[%START_TIME%]\" \"%REQ(:METHOD)%\" \"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\" \"%RESPONSE_CODE%\" \"%DURATION%\" # Json format fields order isn't preserved # The output example: # {\"start_time\":\"2021-12-15T16:46:52.135Z\",\"path\":\"/\",\"response_code\":200,\"method\":\"GET\",\"duration\":1} json_template : start_time : \"%START_TIME%\" method : \"%REQ(:METHOD)%\" path : \"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\" response_code : \"%RESPONSE_CODE%\" duration : \"%DURATION%\" # TLS configuration # tls: # cipherSuites: # - ECDHE-ECDSA-AES128-SHA # - ECDHE-RSA-AES128-SHA # - AES128-GCM-SHA256 # tlsMinimumProtocolVersion: TLSv1_2 # tlsMaximumProtocolVersion: TLSv1_3 # https_redirect_hosts: # - \"example.com\" # - \"my-other-example.com\" # tlsSecrets: # - secretRef: my-cert # namespace: default","title":"Envoy Fleet"},{"location":"customresources/envoyfleet/#envoy-fleet","text":"This resource defines the Envoy Fleet, which is the implementation of the gateway in Kubernetes based on Envoy Proxy. Once the resource manifest is deployed to Kubernetes, it is used by Kusk Gateway Manager to set up K8s Envoy Proxy Deployment , ConfigMap and Service . The ConfigMap config bootstraps Envoy Proxy to connect to the XDS service of the KGW Manager to retrieve the configuration. In its initial state there is a minimal configuration, you have to deploy API or StaticRoute resource to set up the routing. If the Custom Resource is uninstalled, the Manager deletes the created K8s resources. You can deploy multiple Envoy Fleets and have multiple Gateways available. Once the Fleet is deployed, its status field shows the success of the process (Deployed, Failed), so it can be shown with kubectl describe envoyfleet command.","title":"Envoy Fleet"},{"location":"customresources/envoyfleet/#limitations","text":"Currently, only the success of K8s resources deployment is shown, not if the Envoy Proxy pods are alive or if the Service has the External IP Address allocated. Supported parameters: metadata. name and metadata. namespace - Used as the Envoy Fleet ID. The Manager will supply the configuration for this specific ID - Envoy will connect to the KGW Manager with it. API/Static Route can be deployed to this fleet using their fleet name field. spec. image - The Envoy Proxy container image tag, usually envoyproxy/envoy-alpine. spec. service - Defines the configuration of the K8s Service that exposes the Envoy Proxy deployment. It is similar to the K8s Service configuration but with a limited set of fields. spec.service. type - Select the Service Type (NodePort, ClusterIP, LoadBalancer). spec.service. ports - Expose TCP ports (80, 443 or any other) routed to the ports names that Deployment exposes (http, https); ports to which the Envoy Proxy listener binds. spec.service. annotations - Add annotations to the Service that will control load balancer configuration in the specific cloud providers implementations (e.g. to set up the internal Google Cloud Platform load balancer in the Google Cloud Engine, we annotate Service with the related annotation). spec.service. loadBalancerIP - Used to specify the pre-allocated Load Balancer IP address so it won't be deleted in case the Service is deleted. spec.service. externalTrafficPolicy - Optional parameter that denotes if this Service routes external traffic to node-local or cluster-wide endpoints. Local preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. Cluster obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading. For the preservation of the real client IP in access logs, choose \"Local\" spec. size - Optional parameter to specify the number of Envoy Proxy pods in the K8s deployment. If not specified, defaults to 1. spec. resources - Optional parameter that configures the Envoy Proxy container CPU/Memory requests and limits. Read Resource Management for Pods and Containers for the details. By default, no requests or limits are specified. spec. annotations - Optional parameter that adds additional annotations to the Envoy Proxy pods, e.g. for Prometheus scraping. spec. nodeSelector , spec. tolerations and spec. affinity - Optional parameters that provide the Envoy Proxy deployment settings for the K8s Pod scheduler. Read Assigning Pods to Nodes to understand how can you bind Envoy pods to some types of nodes (e.g. non-preemtible node type pool) and how to ensure that Envoy pods are placed onto the different nodes for High Availability. See the YAML example below, too. The structure of these fields are the same as for K8s Deployment. These options can be used simultaneously, influencing each other. spec. accesslog - Optional parameter that defines Envoy Proxy stdout HTTP requests logging. Each Envoy pod can stream the access log to stdout. If not specified, no streaming occurs. If specified, you must chose the format and, optionally, the text or JSON template to tune the output. spec.accesslog. format - Required parameter that specifies the format of the output: JSON (structured) or text . Note that JSON format doesn't preserve fields order. spec.accesslog. text_template | json_template - Optional parameters that could be used to specify the exact Envoy request data to log. See Envoy's Access Logging for the details. If not specified, Kusk Gateway provided defaults. spec. tls - Optional parameter that defines TLS settings for the Envoy Fleet. If not specified, the Envoy Fleet will accept only HTTP traffic. spec.tls. cipherSuites - An optional field that, when specified, the TLS listener will only support the specified cipher list when negotiating TLS 1.0 or 1.2 (this setting has no effect when negotiating TLS 1.3). If not specified, a default list will be used. Defaults are different for server (downstream) and client (upstream) TLS configurations. For more information see: Envoy's Common TLS Configuration . spec.tls. tlsMinimumProtocolVersion - An optional field specifying the minimum TLS protocol version. By default, TLSv1_2 for clients and TLSv1_0 for servers. spec.tls. tlsMaximumProtocolVersion - An optional field specifying the maximum TLS protocol version. By default, TLSv1_2 for clients and TLSv1_3 for servers. spec.tls. https_redirect_hosts - An optional field specifying the domain names to force use of HTTPS with. Non-secure HTTP requests with the matched Host header will be automatically redirected to secure HTTPS with the \"301 Moved Permanently\" code. spec.tls. tlsSecrets - Secret name and namespace combinations for locating TLS secrets containing TLS certificates. More than one may be specified. Kusk Gateway Manager pulls the certificates from the secrets, extracts the matching hostnames from the SubjectAlternativeNames (SAN) certificate field and configures Envoy to use that certificate for those hostnames. spec.tls.tlsSecrets. secretRef - The name of the Kubernetes secret containing the TLS certificate. spec.tls.tlsSecrets. namespace - The namespace where the Kubernetes secret resides. apiVersion : gateway.kusk.io/v1alpha1 kind : EnvoyFleet metadata : name : default namespace : default spec : image : \"envoyproxy/envoy-alpine:v1.20.0\" service : # NodePort, ClusterIP, LoadBalancer type : LoadBalancer # Specify annotations to modify service behaviour, e.g. for GCP to create internal load balancer: # annotations: # networking.gke.io/load-balancer-type: \"Internal\" # Specify preallocated static load balancer IP address if present #loadBalancerIP: 10.10.10.10 ports : - name : http port : 80 targetPort : http - name : https port : 443 targetPort : http # externalTrafficPolicy: Cluster|Local resources : # limits: # cpu: 1 # memory: 100M requests : cpu : 10m memory : 100M # Put any additional annotations to the Enovy pod. # Here we add the annotations for the Prometheus service discovery to scrape Envoy pods for the Prometheus metrics. # annotations: # prometheus.io/scrape: 'true' # prometheus.io/port: '19000' # prometheus.io/path: /stats/prometheus ##### Scheduling directives # Read https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/ for the details. # Optional - schedule Envoy pods to the node with the label \"disktype=ssd\". # nodeSelector: # disktype: \"ssd\" # Optional - allow to be scheduled on the \"tainted\" node. Taint with \"kubectl taint nodes node1 key1=value1:NoSchedule\". # Taints will repel the pods from the node unless the pods have the specific toleration. # The line below will allow this specific Envoy pod to be scheduled there (but scheduler decideds where to put it anyway). # tolerations: # - key: \"key1\" # operator: \"Exists\" # effect: \"NoSchedule\" # Optional - provide pods affinity and anti-affinity settings. # This is more flexible than nodeSelector scheme, but they can be specified together. # For the scalability and fault tolerance we prefer to put all Envoy pods onto different nodes - in a case one node fails we survive on others. # The block below will search for all matching labels of THIS \"default\" envoy fleet pods and will try to schedule pods onto different nodes. # Other fleets (if present) are not taken into consideration. You can specify nodeAffinity and podAffinity as well. # affinity: # podAntiAffinity: # requiredDuringSchedulingIgnoredDuringExecution: # - labelSelector: # matchExpressions: # - key: app.kubernetes.io/name # operator: In # values: # - kusk-gateway-envoy-fleet # - key: fleet # operator: In # values: # - default # topologyKey: kubernetes.io/hostname # optional, the number of Envoy Proxy pods to start size : 1 # Access logging to stdout # Optional, if this is missing no access logging to stdout will be done accesslog : # json|text format : text # Depending on format we can specify our own log template or if template is not specified - default Kusk Gateway will be used. # See https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#config-access-log-format-strings for the details. # Below are specified the examples of similar and minimalistic formats for both text and json format types. # Text format fields order is preserved. # The output example: # \"[2021-12-15T16:50:50.217Z]\" \"GET\" \"/\" \"200\" \"1\" text_template : | \"[%START_TIME%]\" \"%REQ(:METHOD)%\" \"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\" \"%RESPONSE_CODE%\" \"%DURATION%\" # Json format fields order isn't preserved # The output example: # {\"start_time\":\"2021-12-15T16:46:52.135Z\",\"path\":\"/\",\"response_code\":200,\"method\":\"GET\",\"duration\":1} json_template : start_time : \"%START_TIME%\" method : \"%REQ(:METHOD)%\" path : \"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\" response_code : \"%RESPONSE_CODE%\" duration : \"%DURATION%\" # TLS configuration # tls: # cipherSuites: # - ECDHE-ECDSA-AES128-SHA # - ECDHE-RSA-AES128-SHA # - AES128-GCM-SHA256 # tlsMinimumProtocolVersion: TLSv1_2 # tlsMaximumProtocolVersion: TLSv1_3 # https_redirect_hosts: # - \"example.com\" # - \"my-other-example.com\" # tlsSecrets: # - secretRef: my-cert # namespace: default","title":"Limitations"},{"location":"customresources/overview/","text":"Kusk Custom Resources Kusk Gateway defines a number of Kubernetes CRDs for managing its configuration. These are installed as part of the Kusk Gateway installation process. Kusk Gateway uses the following CRDs: Envoy Fleet - For managing Envoy deployments. API - For using an OpenAPI definition to configure Gateway behaviour. Static Route - For exposing static content through Kusk Gateway.","title":"Overview"},{"location":"customresources/overview/#kusk-custom-resources","text":"Kusk Gateway defines a number of Kubernetes CRDs for managing its configuration. These are installed as part of the Kusk Gateway installation process. Kusk Gateway uses the following CRDs: Envoy Fleet - For managing Envoy deployments. API - For using an OpenAPI definition to configure Gateway behaviour. Static Route - For exposing static content through Kusk Gateway.","title":"Kusk Custom Resources"},{"location":"customresources/staticroute/","text":"Static Route This resource defines manually created routing rules. It is useful to set up the routing to a non-API application, e.g. static pages or images or to route to legacy, possibly external to the cluster, APIs. The Static Route resource is designed to overcome the shortcomings of OpenAPI based routing, one of which is the inability to configure \"catch all prefixes\" like / . Its structure is still similar to OpenAPI and, thus, familiar to users. The resource can be deployed to the API resource or completely separately. Routing information from both resources will be merged with the priority given to the API resources. Once the resource manifest is deployed, Kusk Gateway Manager will use it to configure routing for Envoy Fleet. Multiple resources can exist in different namespaces, all of them will be evaluated and the configuration merged on any action with the separate resource. Trying to apply a resource that has conflicting routes with the existing resources (i.e. same HTTP method and path) will be rejected with the error. Limitations Currently, the resource status field is not updated by the manager when the reconciliation of the configuration finishes. Configuration Structure Description The main elements of the configuration are in the spec field. The elements specify how the incoming request is matched and what action to take. Below is the YAML structure of the configuration. Please read further for a full explanation. apiVersion : gateway.kusk.io/v1alpha1 kind : StaticRoute metadata : name : staticroute-sample spec : # Envoy Fleet (its name and namespace) to deploy the configuration to, here - deployed EnvoyFleet with the name \"default\" in the namespace \"default\". # Optional, if not specified - single (default) fleet autodetection will be performed in the cluster. fleet : name : default namespace : default hosts : [ <string> , <string> , ... ] paths : # Consists of path matchers with HTTP methods (lowercase), which in turn either: # 1. \"route\" (proxying) to the upstream host or # 2. \"redirect\" to other endpoint <path_match> : <http_method> : # \"route\" defines proxying parameters. Mutually exclusive with \"redirect\". route : # upstream is the container for the upstream host specification. upstream : # host defines the hostname to proxy to. Mutually exclusive with service. host : # DNS name to proxy to hostname : <string> # Port to proxy to port : <int> # service is the convenient way to configure proxying to Kubernetes services. Mutually exclusive with the \"host\". service : # service name name : <string> namespace : <string> port : 8080 # rewrites path with the regex and substitution patterns. rewrite : pattern : <string> # path regex pattern substitution : <string> # path substitution pattern. # Optional qos : # the timeout for the upstream connection, seconds. 0 means forever, if unspecified - 15 seconds. request_timeout : <int> # the timeout for the idle upstream of downstream connection, seconds. 0 means forever, unspecified default 1h. idle_timeout : <int> # retries define how many retries to upstream with failed (50x code) requests, number. Default 1. retries : <int> # Optional cors : # allowed origins returned in Access-Control-Allow-Origin header # the list of domain names # Note - regex other than the wildcard (\"*\") are not supported right now. origins : - \"*\" # allowed methods to call this endpoint returned in Access-Control-Allow-Methods header # the list of methods methods : - POST - GET # allowed headers returned in Access-Control-Allow-Headers header # the list of headers headers : - Content-Type # allow browser to send credentials, returned with Access-Control-Allow-Credentials header credentials : <true|false> # allowed headers that browser can access returned with Access-Control-Expose-Headers header # the list of headers expose_headers : - X-Custom-Header1 - X-Custom-Header2 # how long to cache this CORS information for the browser, returned with Access-Control-Max-Age. max_age : <int> # Enable establishing Websockets connections websocket : <true|false> # \"redirect\" creates HTTP redirect to other endpoint. Mutually exclusive with \"route\". redirect : # redirect to http or https scheme_redirect : <http|https> # redirect to this hostname host_redirect : <string> # redirects to different port port_redirect : <int> # redirect to different URL path. Mutually exclusive with rewrite_regex. path_redirect : \"<string>\" # redirect using the rewrite rule. Mutually exclusive with path_redirect. rewrite_regex : # regex pattern : <string> # regex parameters substitution pattern substitution : <string> # response code, by default - Permanent Redirect HTTP 308 # available HTTP codes: 301, 302, 303, 307, 308 response_code : <int> <http_method> : -- skipped -- Envoy Fleet The spec. fleet optional field specifies to which Envoy Fleet (Envoy Proxy instances with the exposing K8s Service) this configuration applies. fleet. name and fleet. namespace reference the deployed Envoy Fleet Custom Resource name and namespace. You can deploy a Static Route configuration in any namespace with any name and it will be applied to the specific Envoy Fleet. If this option is missing, the autodetection will be performed to find the single fleet deployed in the Kubernetes cluster Fleet, which is then considered as the default Fleet. The deployed Static Route custom resource will be changed to map to that fleet accordingly. If there are multiple fleets deployed, spec. fleet is required to specify which in the manifest. Request Matching We match the incoming request by HOST header, path and HTTP method. The following fields specify matching: hosts - Defines the list of HOST headers to which the current configuration applies. This will create the Envoy's VirtualHost with the same name and domain matching. Wildcards are possible, e.g. \"*\" means \"any host\". Prefix and suffix wildcards are supported, but not both (i.e. example.*, *example.com , but not *example* ). paths - The container of URL paths and HTTP methods collection to match and handle the request during the routing decision. paths . path_match is the URL path string and starts with / (e.g. /api , /robots.txt ). The suffix hints how to match the request: Paths ending with / will match everything that has that path as a prefix. E.g. /api/ matches /api/v1/id , just / is a catch all. Paths without / will match that path exactly. For example, /resource matches exactly this resource with any possible URL query. Alpha limitations: Regexes are currently not supported. paths . path_match . http_method - Adds an additional request matcher which is the lowercase HTTP method (get, post, ...). Calls to the paths with a method not set here will return \"404 Not Found\". Final Action on the Matched Request Once the request is matched, we can decide what to do with it. paths . path_match .http_method_match. route|redirect specifies the routing decision. The request can be either proxied to the upstream host (backend) or returned to the user as a redirect. Either redirect or route must be specified, but not both. Alpha Limitations: Currently additional request handling (e.g. direct request response like returning 404 Not Found) is not implemented. Redirect redirect provides HTTP redirect options with the following fields. All of them are optional but, once specified, enable a part of redirection behaviour. redirect structure: redirect : scheme_redirect : <http|https> # redirect to http or https. host_redirect : <string> # redirect to this hostname. port_redirect : <string> # redirect to this port. path_redirect : <string> # redirect to this path, old path is removed. Mutually exclusive with rewrite_regex. rewrite_regex : # redirect to this rewritten with regex path. Mutually exclusive with path_redirect. pattern : <string> # path regex pattern substitution : <string> # path substitution pattern. response_code : # redirect HTTP response code to return to the user. Available HTTP codes: 301, 302, 303, 307, 308 strip_query : <bool> # strip path query during redirect, default false. rewrite_regex pattern matching and substitution provides a powerful mechanism to rewrite redirect path based on incoming requests. From Envoy's documentation: Indicates that during redirect, portions of the path that match the pattern should be rewritten, even allowing the substitution of capture groups from the pattern into the new path as specified by the rewrite substitution string. This is useful to allow application paths to be rewritten in a way that is aware of segments with variable content like identifiers. Examples using Google\u2019s RE2 engine: The path pattern ^/service/([^/]+)(/.*)$ paired with a substitution string of \\2/instance/\\1 would transform /service/foo/v1/api into /v1/api/instance/foo. The pattern one paired with a substitution string of two would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/two/zzz. The pattern ^(. ?)one(. )$ paired with a substitution string of \\1two\\2 would replace only the first occurrence of one, transforming path /xxx/one/yyy/one/zzz into /xxx/two/yyy/one/zzz. The pattern (?i)/xxx/ paired with a substitution string of /yyy/ would do a case-insensitive match and transform path /aaa/XxX/bbb to /aaa/yyy/bbb. Route route specifies how the request will be proxied to the upstream with the following fields: route structure: route : # upstream is the container for the upstream host specification. Either upstream.host or upstream.service must be specified. upstream : # host defines the hostname to proxy to. Mutually exclusive with service. host : # DNS hostname to proxy to hostname : <string> # host port port : <int> # service is the convenient way to configure proxying to Kubernetes services. Mutually exclusive with the \"host\". service : # K8s service name to proxy to name : <string> # service namespace namespace : <string> # service port port : <int> # rewrites path with the regex and substitution patterns. rewrite : pattern : <string> # path regex pattern substitution : <string> # path substitution pattern. # Quality of Service for the request # Optional qos : # the timeout for the upstream connection, seconds. 0 means forever, if unspecified - 15 seconds. request_timeout : <int> # the timeout for the idle upstream of downstream connection, seconds. 0 means forever, unspecified default 1h. idle_timeout : <int> # retries define how many retries to upstream with failed (50x code) requests, number. Default 1. retries : <int> # Optional cors : # allowed origins returned in Access-Control-Allow-Origin header # the list of domain names # Note - regex other than the wildcard (\"*\") are not supported right now. # WARNING - this is just the example, write your own CORS settings. origins : - \"*\" # allowed methods to call this endpoint returned in Access-Control-Allow-Methods header # the list of methods methods : - POST - GET # allowed headers returned in Access-Control-Allow-Headers header # the list of headers headers : - Content-Type # allow browser to send credentials, returned with Access-Control-Allow-Credentials header credentials : <true|false> # allowed headers that browser can access returned with Access-Control-Expose-Headers header # the list of headers expose_headers : - X-Custom-Header1 - X-Custom-Header2 # how long to cache this CORS information for the browser in seconds, returned with Access-Control-Max-Age header max_age : <int> # Enable establishing Websockets connections websocket : <true|false> route . upstream - A required field that defines the upstream host parameters. We proxy using DNS hostname or local cluster K8s service parameters, which are further resolved to DNS hostname. Either upstream . host or upstream . service must be specified inside. route . upstream . rewrite - An optional field that specifies what to do with the URL path when proxying to the upstream. The only value currently is rewrite . See the rewrite_regex section in redirect action above for the explanation. route . qos - An optional field that is the container for request Quality of Service parameters, i.e. timeouts, failure retry policy. route . cors - An optional field that is the container for Cross-Origin Resource Sharing headers parameters. If this field is specified, the route will be augmented with CORS preflight OPTIONS HTTP method matching. This will allow Envoy to return the response to the OPTIONS request with the specified CORS headers to the user without proxying to upstream. It is advised to read CORS before trying to configure this. Note: The structure for CORS specified above is an example; users should write their own set of methods and headers. route . websocket - An optional boolean field that defines whether to enable handling of \"Upgrade: websocket\" and related Websocket HTTP headers in the request to create a Websocket tunnel to the backend. The default is false - don't handle Websockets. Example apiVersion : gateway.kusk.io/v1alpha1 kind : StaticRoute metadata : name : sample spec : # should work with localhost, example.org, any host hosts : [ \"localhost\" , \"*\" ] paths : # Catch all prefix / / : # HTTP method GET get : route : &root_route # here we're using YAML anchors to decrease the boilerplate for all HTTP methods - the configuration is the same. upstream : host : # DNS name to proxy forward to hostname : front.somehostname.com # Port to proxy to port : 80 post : *root_route put : *root_route head : *root_route patch : *root_route # robots.txt is served by the new frontend. Here we use \"host\" to show that it can replace \"service\" safely. /robots.txt : get : route : upstream : host : hostname : front.frontapps.svc.cluster.local. port : 80 # GET to /oldstatic resource redirects to /static /oldstatic/ : get : redirect : # redirect to different path /oldstatic/blabla -> /static/blabla rewrite_regex : pattern : '/oldstatic/(.*)' substitution : '/static/\\1' response_code : 308 /static/ : get : route : upstream : service : name : \"front\" namespace : \"frontapps\" port : 80 # GET to /images/ is proxied to K8s service images in images namespace /images/ : get : route : upstream : service : name : images namespace : images port : 8080 # old API is served on other path with the rewrite of path to upstream /api/v0/ : get : route : &old_api_route upstream : service : name : api0 namespace : legacy port : 80 # removes /api/v0 from the path when proxying to upstream rewrite : pattern : \"^/api/v0\" substitution : \"\" # Old API is slow and unreliable qos : request_timeout : 30 idle_timeout : 60 retries : 5 cors : origins : - \"*\" methods : - GET - POST - PUT - PATCH - HEAD headers : - Content-Type - Content-Encoding credentials : false expose_headers : - X-API-VERSION max_age : 8600 websocket : true post : *old_api_route put : *old_api_route patch : *old_api_route head : *old_api_route","title":"Static Route"},{"location":"customresources/staticroute/#static-route","text":"This resource defines manually created routing rules. It is useful to set up the routing to a non-API application, e.g. static pages or images or to route to legacy, possibly external to the cluster, APIs. The Static Route resource is designed to overcome the shortcomings of OpenAPI based routing, one of which is the inability to configure \"catch all prefixes\" like / . Its structure is still similar to OpenAPI and, thus, familiar to users. The resource can be deployed to the API resource or completely separately. Routing information from both resources will be merged with the priority given to the API resources. Once the resource manifest is deployed, Kusk Gateway Manager will use it to configure routing for Envoy Fleet. Multiple resources can exist in different namespaces, all of them will be evaluated and the configuration merged on any action with the separate resource. Trying to apply a resource that has conflicting routes with the existing resources (i.e. same HTTP method and path) will be rejected with the error.","title":"Static Route"},{"location":"customresources/staticroute/#limitations","text":"Currently, the resource status field is not updated by the manager when the reconciliation of the configuration finishes.","title":"Limitations"},{"location":"customresources/staticroute/#configuration-structure-description","text":"The main elements of the configuration are in the spec field. The elements specify how the incoming request is matched and what action to take. Below is the YAML structure of the configuration. Please read further for a full explanation. apiVersion : gateway.kusk.io/v1alpha1 kind : StaticRoute metadata : name : staticroute-sample spec : # Envoy Fleet (its name and namespace) to deploy the configuration to, here - deployed EnvoyFleet with the name \"default\" in the namespace \"default\". # Optional, if not specified - single (default) fleet autodetection will be performed in the cluster. fleet : name : default namespace : default hosts : [ <string> , <string> , ... ] paths : # Consists of path matchers with HTTP methods (lowercase), which in turn either: # 1. \"route\" (proxying) to the upstream host or # 2. \"redirect\" to other endpoint <path_match> : <http_method> : # \"route\" defines proxying parameters. Mutually exclusive with \"redirect\". route : # upstream is the container for the upstream host specification. upstream : # host defines the hostname to proxy to. Mutually exclusive with service. host : # DNS name to proxy to hostname : <string> # Port to proxy to port : <int> # service is the convenient way to configure proxying to Kubernetes services. Mutually exclusive with the \"host\". service : # service name name : <string> namespace : <string> port : 8080 # rewrites path with the regex and substitution patterns. rewrite : pattern : <string> # path regex pattern substitution : <string> # path substitution pattern. # Optional qos : # the timeout for the upstream connection, seconds. 0 means forever, if unspecified - 15 seconds. request_timeout : <int> # the timeout for the idle upstream of downstream connection, seconds. 0 means forever, unspecified default 1h. idle_timeout : <int> # retries define how many retries to upstream with failed (50x code) requests, number. Default 1. retries : <int> # Optional cors : # allowed origins returned in Access-Control-Allow-Origin header # the list of domain names # Note - regex other than the wildcard (\"*\") are not supported right now. origins : - \"*\" # allowed methods to call this endpoint returned in Access-Control-Allow-Methods header # the list of methods methods : - POST - GET # allowed headers returned in Access-Control-Allow-Headers header # the list of headers headers : - Content-Type # allow browser to send credentials, returned with Access-Control-Allow-Credentials header credentials : <true|false> # allowed headers that browser can access returned with Access-Control-Expose-Headers header # the list of headers expose_headers : - X-Custom-Header1 - X-Custom-Header2 # how long to cache this CORS information for the browser, returned with Access-Control-Max-Age. max_age : <int> # Enable establishing Websockets connections websocket : <true|false> # \"redirect\" creates HTTP redirect to other endpoint. Mutually exclusive with \"route\". redirect : # redirect to http or https scheme_redirect : <http|https> # redirect to this hostname host_redirect : <string> # redirects to different port port_redirect : <int> # redirect to different URL path. Mutually exclusive with rewrite_regex. path_redirect : \"<string>\" # redirect using the rewrite rule. Mutually exclusive with path_redirect. rewrite_regex : # regex pattern : <string> # regex parameters substitution pattern substitution : <string> # response code, by default - Permanent Redirect HTTP 308 # available HTTP codes: 301, 302, 303, 307, 308 response_code : <int> <http_method> : -- skipped --","title":"Configuration Structure Description"},{"location":"customresources/staticroute/#envoy-fleet","text":"The spec. fleet optional field specifies to which Envoy Fleet (Envoy Proxy instances with the exposing K8s Service) this configuration applies. fleet. name and fleet. namespace reference the deployed Envoy Fleet Custom Resource name and namespace. You can deploy a Static Route configuration in any namespace with any name and it will be applied to the specific Envoy Fleet. If this option is missing, the autodetection will be performed to find the single fleet deployed in the Kubernetes cluster Fleet, which is then considered as the default Fleet. The deployed Static Route custom resource will be changed to map to that fleet accordingly. If there are multiple fleets deployed, spec. fleet is required to specify which in the manifest.","title":"Envoy Fleet"},{"location":"customresources/staticroute/#request-matching","text":"We match the incoming request by HOST header, path and HTTP method. The following fields specify matching: hosts - Defines the list of HOST headers to which the current configuration applies. This will create the Envoy's VirtualHost with the same name and domain matching. Wildcards are possible, e.g. \"*\" means \"any host\". Prefix and suffix wildcards are supported, but not both (i.e. example.*, *example.com , but not *example* ). paths - The container of URL paths and HTTP methods collection to match and handle the request during the routing decision. paths . path_match is the URL path string and starts with / (e.g. /api , /robots.txt ). The suffix hints how to match the request: Paths ending with / will match everything that has that path as a prefix. E.g. /api/ matches /api/v1/id , just / is a catch all. Paths without / will match that path exactly. For example, /resource matches exactly this resource with any possible URL query. Alpha limitations: Regexes are currently not supported. paths . path_match . http_method - Adds an additional request matcher which is the lowercase HTTP method (get, post, ...). Calls to the paths with a method not set here will return \"404 Not Found\".","title":"Request Matching"},{"location":"customresources/staticroute/#final-action-on-the-matched-request","text":"Once the request is matched, we can decide what to do with it. paths . path_match .http_method_match. route|redirect specifies the routing decision. The request can be either proxied to the upstream host (backend) or returned to the user as a redirect. Either redirect or route must be specified, but not both. Alpha Limitations: Currently additional request handling (e.g. direct request response like returning 404 Not Found) is not implemented.","title":"Final Action on the Matched Request"},{"location":"customresources/staticroute/#redirect","text":"redirect provides HTTP redirect options with the following fields. All of them are optional but, once specified, enable a part of redirection behaviour. redirect structure: redirect : scheme_redirect : <http|https> # redirect to http or https. host_redirect : <string> # redirect to this hostname. port_redirect : <string> # redirect to this port. path_redirect : <string> # redirect to this path, old path is removed. Mutually exclusive with rewrite_regex. rewrite_regex : # redirect to this rewritten with regex path. Mutually exclusive with path_redirect. pattern : <string> # path regex pattern substitution : <string> # path substitution pattern. response_code : # redirect HTTP response code to return to the user. Available HTTP codes: 301, 302, 303, 307, 308 strip_query : <bool> # strip path query during redirect, default false. rewrite_regex pattern matching and substitution provides a powerful mechanism to rewrite redirect path based on incoming requests. From Envoy's documentation: Indicates that during redirect, portions of the path that match the pattern should be rewritten, even allowing the substitution of capture groups from the pattern into the new path as specified by the rewrite substitution string. This is useful to allow application paths to be rewritten in a way that is aware of segments with variable content like identifiers. Examples using Google\u2019s RE2 engine: The path pattern ^/service/([^/]+)(/.*)$ paired with a substitution string of \\2/instance/\\1 would transform /service/foo/v1/api into /v1/api/instance/foo. The pattern one paired with a substitution string of two would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/two/zzz. The pattern ^(. ?)one(. )$ paired with a substitution string of \\1two\\2 would replace only the first occurrence of one, transforming path /xxx/one/yyy/one/zzz into /xxx/two/yyy/one/zzz. The pattern (?i)/xxx/ paired with a substitution string of /yyy/ would do a case-insensitive match and transform path /aaa/XxX/bbb to /aaa/yyy/bbb.","title":"Redirect"},{"location":"customresources/staticroute/#route","text":"route specifies how the request will be proxied to the upstream with the following fields: route structure: route : # upstream is the container for the upstream host specification. Either upstream.host or upstream.service must be specified. upstream : # host defines the hostname to proxy to. Mutually exclusive with service. host : # DNS hostname to proxy to hostname : <string> # host port port : <int> # service is the convenient way to configure proxying to Kubernetes services. Mutually exclusive with the \"host\". service : # K8s service name to proxy to name : <string> # service namespace namespace : <string> # service port port : <int> # rewrites path with the regex and substitution patterns. rewrite : pattern : <string> # path regex pattern substitution : <string> # path substitution pattern. # Quality of Service for the request # Optional qos : # the timeout for the upstream connection, seconds. 0 means forever, if unspecified - 15 seconds. request_timeout : <int> # the timeout for the idle upstream of downstream connection, seconds. 0 means forever, unspecified default 1h. idle_timeout : <int> # retries define how many retries to upstream with failed (50x code) requests, number. Default 1. retries : <int> # Optional cors : # allowed origins returned in Access-Control-Allow-Origin header # the list of domain names # Note - regex other than the wildcard (\"*\") are not supported right now. # WARNING - this is just the example, write your own CORS settings. origins : - \"*\" # allowed methods to call this endpoint returned in Access-Control-Allow-Methods header # the list of methods methods : - POST - GET # allowed headers returned in Access-Control-Allow-Headers header # the list of headers headers : - Content-Type # allow browser to send credentials, returned with Access-Control-Allow-Credentials header credentials : <true|false> # allowed headers that browser can access returned with Access-Control-Expose-Headers header # the list of headers expose_headers : - X-Custom-Header1 - X-Custom-Header2 # how long to cache this CORS information for the browser in seconds, returned with Access-Control-Max-Age header max_age : <int> # Enable establishing Websockets connections websocket : <true|false> route . upstream - A required field that defines the upstream host parameters. We proxy using DNS hostname or local cluster K8s service parameters, which are further resolved to DNS hostname. Either upstream . host or upstream . service must be specified inside. route . upstream . rewrite - An optional field that specifies what to do with the URL path when proxying to the upstream. The only value currently is rewrite . See the rewrite_regex section in redirect action above for the explanation. route . qos - An optional field that is the container for request Quality of Service parameters, i.e. timeouts, failure retry policy. route . cors - An optional field that is the container for Cross-Origin Resource Sharing headers parameters. If this field is specified, the route will be augmented with CORS preflight OPTIONS HTTP method matching. This will allow Envoy to return the response to the OPTIONS request with the specified CORS headers to the user without proxying to upstream. It is advised to read CORS before trying to configure this. Note: The structure for CORS specified above is an example; users should write their own set of methods and headers. route . websocket - An optional boolean field that defines whether to enable handling of \"Upgrade: websocket\" and related Websocket HTTP headers in the request to create a Websocket tunnel to the backend. The default is false - don't handle Websockets.","title":"Route"},{"location":"customresources/staticroute/#example","text":"apiVersion : gateway.kusk.io/v1alpha1 kind : StaticRoute metadata : name : sample spec : # should work with localhost, example.org, any host hosts : [ \"localhost\" , \"*\" ] paths : # Catch all prefix / / : # HTTP method GET get : route : &root_route # here we're using YAML anchors to decrease the boilerplate for all HTTP methods - the configuration is the same. upstream : host : # DNS name to proxy forward to hostname : front.somehostname.com # Port to proxy to port : 80 post : *root_route put : *root_route head : *root_route patch : *root_route # robots.txt is served by the new frontend. Here we use \"host\" to show that it can replace \"service\" safely. /robots.txt : get : route : upstream : host : hostname : front.frontapps.svc.cluster.local. port : 80 # GET to /oldstatic resource redirects to /static /oldstatic/ : get : redirect : # redirect to different path /oldstatic/blabla -> /static/blabla rewrite_regex : pattern : '/oldstatic/(.*)' substitution : '/static/\\1' response_code : 308 /static/ : get : route : upstream : service : name : \"front\" namespace : \"frontapps\" port : 80 # GET to /images/ is proxied to K8s service images in images namespace /images/ : get : route : upstream : service : name : images namespace : images port : 8080 # old API is served on other path with the rewrite of path to upstream /api/v0/ : get : route : &old_api_route upstream : service : name : api0 namespace : legacy port : 80 # removes /api/v0 from the path when proxying to upstream rewrite : pattern : \"^/api/v0\" substitution : \"\" # Old API is slow and unreliable qos : request_timeout : 30 idle_timeout : 60 retries : 5 cors : origins : - \"*\" methods : - GET - POST - PUT - PATCH - HEAD headers : - Content-Type - Content-Encoding credentials : false expose_headers : - X-API-VERSION max_age : 8600 websocket : true post : *old_api_route put : *old_api_route patch : *old_api_route head : *old_api_route","title":"Example"},{"location":"dashboard/deploying-apis/","text":"Deploying APIs The Kusk Dashboard contains a wizard for helping you deploy your vanilla OpenAPI definitions to Kusk Gateway. It will prompt and add any required x-kusk extensions for you, so you can try different configurations without having to add the corresponding properties manually. Open the wizard with the \"Publish new API\" button on the top right. Paste your OpenAPI 3.x definition in the initial text field and proceed through the steps of the wizard as needed. As soon as your API has enough configuration to be publishable, the \"Publish\" button in the bottom right will be enabled, allowing you to bypass any steps that aren't further required. For example, if you select \"Enable mocking\" on the first page, you can immediately publish your API, as it requires no other configuration when being mocked.","title":"Deploying APIs"},{"location":"dashboard/deploying-apis/#deploying-apis","text":"The Kusk Dashboard contains a wizard for helping you deploy your vanilla OpenAPI definitions to Kusk Gateway. It will prompt and add any required x-kusk extensions for you, so you can try different configurations without having to add the corresponding properties manually. Open the wizard with the \"Publish new API\" button on the top right. Paste your OpenAPI 3.x definition in the initial text field and proceed through the steps of the wizard as needed. As soon as your API has enough configuration to be publishable, the \"Publish\" button in the bottom right will be enabled, allowing you to bypass any steps that aren't further required. For example, if you select \"Enable mocking\" on the first page, you can immediately publish your API, as it requires no other configuration when being mocked.","title":"Deploying APIs"},{"location":"dashboard/inspecting-apis/","text":"Inspecting Deployed APIs Selecting a deployed API in the dashboard opens a corresponding details panel to the right containing 3 tabs: API Definition : Shows an extended Swagger UI for the OpenAPI that was deployed to Kusk Gateway. Kusk Extensions : Shows an overview of all x-kusk extensions in the deployed OpenAPI definition. Public API Definition : Shows Swagger UI for the OpenAPI definition that would be exposed to consumers. API Definition Tab The API definition tab shows a Swagger UI for the deployed API definition - together with a table of contents at the top, making it easy to navigate to individual operations. An indicator is shown next to any level in the Table of Contents if there is a x-kusk extension defined. Clicking it will open the corresponding extension in the Kusk Extensions tab (see below). Kusk Extensions Tab The Kusk Extensions tab contains a tree view showing all x-kusk extensions that have been specified in the deployed OpenAPI definition - making it easy to understand how the API has been configured for Kusk Gateway. Public API Definition Tab The Public API Definition tab contains the \"post-processed\" OpenAPI definition as you would provide publicly to consumers of your API. This differs from the deployed OpenAPI definition in the following ways: All x-kusk extensions have been removed. All disabled operations have been removed - see Disabling Operations . A Table of Contents is available as in the API Definition tab. This tab includes the possibility to specify server(s) to be used when executing requests through the integrated Swagger UI: Specifying the server used by the dashboard itself allows us to execute requests against the Dashboard API. For example, to get a list of APIs (as seen in the dashboard), we can execute the GET /apis operation.","title":"Inspecting APIs"},{"location":"dashboard/inspecting-apis/#inspecting-deployed-apis","text":"Selecting a deployed API in the dashboard opens a corresponding details panel to the right containing 3 tabs: API Definition : Shows an extended Swagger UI for the OpenAPI that was deployed to Kusk Gateway. Kusk Extensions : Shows an overview of all x-kusk extensions in the deployed OpenAPI definition. Public API Definition : Shows Swagger UI for the OpenAPI definition that would be exposed to consumers.","title":"Inspecting Deployed APIs"},{"location":"dashboard/inspecting-apis/#api-definition-tab","text":"The API definition tab shows a Swagger UI for the deployed API definition - together with a table of contents at the top, making it easy to navigate to individual operations. An indicator is shown next to any level in the Table of Contents if there is a x-kusk extension defined. Clicking it will open the corresponding extension in the Kusk Extensions tab (see below).","title":"API Definition Tab"},{"location":"dashboard/inspecting-apis/#kusk-extensions-tab","text":"The Kusk Extensions tab contains a tree view showing all x-kusk extensions that have been specified in the deployed OpenAPI definition - making it easy to understand how the API has been configured for Kusk Gateway.","title":"Kusk Extensions Tab"},{"location":"dashboard/inspecting-apis/#public-api-definition-tab","text":"The Public API Definition tab contains the \"post-processed\" OpenAPI definition as you would provide publicly to consumers of your API. This differs from the deployed OpenAPI definition in the following ways: All x-kusk extensions have been removed. All disabled operations have been removed - see Disabling Operations . A Table of Contents is available as in the API Definition tab. This tab includes the possibility to specify server(s) to be used when executing requests through the integrated Swagger UI: Specifying the server used by the dashboard itself allows us to execute requests against the Dashboard API. For example, to get a list of APIs (as seen in the dashboard), we can execute the GET /apis operation.","title":"Public API Definition Tab"},{"location":"dashboard/overview/","text":"Kusk Dashboard Kusk Gateway includes a browser-based dashboard for inspecting deployed APIs, Envoy Fleets and Static Routes. For APIs, it is also possible to dig into the underlying OpenAPI definition and make ad-hoc requests to the API using the embedded Swagger UI. The dashboard is installed as part of the Kusk Installation and published using Kusk Gateway via dedicated Envoy Fleet, Static Route and API resources (which you can see in the dashboard). After installing Kusk Gateway, access the dashboard by running: kubectl port-forward -n kusk-system svc/kusk-gateway-private-envoy-fleet 8080 :80 open http://localhost:8080/ This will open the dashboard, showing the kusk-gateway-api API Resource deployed through Kusk Gateway (the API that the dashboard itself uses): Use the tabs on the top left to see deployed EnvoyFleets and StaticRoutes. The following EnvoyFleets are deployed by default: Use the following Static Route for exposing the dashboard itself: Selecting any object will open a details panel to the right showing corresponding information - as shown in the screenshot above for the dashboard Static Route. Setting the API Endpoint By default, the dashboard uses a backend API exposed on the same host as the dashboard itself with an '/api' path prefix. If you host the dashboard or its API differently, you can configure the API endpoint using the Settings button in the bottom left, which opens the following dialog: You can specify any absolute URL or relative path here - just make sure that CORS is configured accordingly if you specify a different host than the default one.","title":"Overview"},{"location":"dashboard/overview/#kusk-dashboard","text":"Kusk Gateway includes a browser-based dashboard for inspecting deployed APIs, Envoy Fleets and Static Routes. For APIs, it is also possible to dig into the underlying OpenAPI definition and make ad-hoc requests to the API using the embedded Swagger UI. The dashboard is installed as part of the Kusk Installation and published using Kusk Gateway via dedicated Envoy Fleet, Static Route and API resources (which you can see in the dashboard). After installing Kusk Gateway, access the dashboard by running: kubectl port-forward -n kusk-system svc/kusk-gateway-private-envoy-fleet 8080 :80 open http://localhost:8080/ This will open the dashboard, showing the kusk-gateway-api API Resource deployed through Kusk Gateway (the API that the dashboard itself uses): Use the tabs on the top left to see deployed EnvoyFleets and StaticRoutes. The following EnvoyFleets are deployed by default: Use the following Static Route for exposing the dashboard itself: Selecting any object will open a details panel to the right showing corresponding information - as shown in the screenshot above for the dashboard Static Route.","title":"Kusk Dashboard"},{"location":"dashboard/overview/#setting-the-api-endpoint","text":"By default, the dashboard uses a backend API exposed on the same host as the dashboard itself with an '/api' path prefix. If you host the dashboard or its API differently, you can configure the API endpoint using the Settings button in the bottom left, which opens the following dialog: You can specify any absolute URL or relative path here - just make sure that CORS is configured accordingly if you specify a different host than the default one.","title":"Setting the API Endpoint"},{"location":"getting-started/connect-a-service-to-the-api/","text":"Connect a Service Once you have created an API and mocked its responses, you are ready to implement the services and connect them to the API. This section explains how you would connect your services to Kusk-gateway. 1. Deploy a Service Create a deployment.yaml file: apiVersion: apps/v1 kind: Deployment metadata: name: hello-world spec: selector: matchLabels: app: hello-world template: metadata: labels: app: hello-world spec: containers: - name: hello-world image: aabedraba/kusk-hello-world:1.0 resources: limits: memory: \"128Mi\" cpu: \"500m\" ports: - containerPort: 8080 --- apiVersion: v1 kind: Service metadata: name: hello-world-svc spec: selector: app: hello-world ports: - port: 8080 targetPort: 8080 And apply it with: kubectl apply -f deployment.yaml 2. Update the API Manifest to Connect the Service to the Gateway Once you have finished implementing and deploying the service, you will need to stop the mocking of the API endpoint and connect the service to the gateway. Stop the API mocking by deleting the mocking section: ... - mocking: - enabled: true ... Add the upstream details, which are the details of the service we just created, under the x-kusk section to connect the gateway to the service. ... x-kusk: + upstream: + service: + name: hello-world-svc + namespace: default + port: 8080 ... 3. Apply the Changes kubectl apply -f api.yaml 4. Test the API Get the External IP of Kusk-gateway as indicated in installing Kusk-gateway section and run: $ curl EXTERNAL_IP/hello Hello from an implemented service! And now you have successfully deployed an API! The approach from this \"Getting Started\" section of the documentation follows a design-first approach where you deployed the API first, mocked the API to and later implemented the services and connected them to the API.","title":"Connect a Service to the API"},{"location":"getting-started/connect-a-service-to-the-api/#connect-a-service","text":"Once you have created an API and mocked its responses, you are ready to implement the services and connect them to the API. This section explains how you would connect your services to Kusk-gateway.","title":"Connect a Service"},{"location":"getting-started/connect-a-service-to-the-api/#1-deploy-a-service","text":"Create a deployment.yaml file: apiVersion: apps/v1 kind: Deployment metadata: name: hello-world spec: selector: matchLabels: app: hello-world template: metadata: labels: app: hello-world spec: containers: - name: hello-world image: aabedraba/kusk-hello-world:1.0 resources: limits: memory: \"128Mi\" cpu: \"500m\" ports: - containerPort: 8080 --- apiVersion: v1 kind: Service metadata: name: hello-world-svc spec: selector: app: hello-world ports: - port: 8080 targetPort: 8080 And apply it with: kubectl apply -f deployment.yaml","title":"1. Deploy a Service"},{"location":"getting-started/connect-a-service-to-the-api/#2-update-the-api-manifest-to-connect-the-service-to-the-gateway","text":"Once you have finished implementing and deploying the service, you will need to stop the mocking of the API endpoint and connect the service to the gateway. Stop the API mocking by deleting the mocking section: ... - mocking: - enabled: true ... Add the upstream details, which are the details of the service we just created, under the x-kusk section to connect the gateway to the service. ... x-kusk: + upstream: + service: + name: hello-world-svc + namespace: default + port: 8080 ...","title":"2. Update the API Manifest to Connect the Service to the Gateway"},{"location":"getting-started/connect-a-service-to-the-api/#3-apply-the-changes","text":"kubectl apply -f api.yaml","title":"3. Apply the Changes"},{"location":"getting-started/connect-a-service-to-the-api/#4-test-the-api","text":"Get the External IP of Kusk-gateway as indicated in installing Kusk-gateway section and run: $ curl EXTERNAL_IP/hello Hello from an implemented service! And now you have successfully deployed an API! The approach from this \"Getting Started\" section of the documentation follows a design-first approach where you deployed the API first, mocked the API to and later implemented the services and connected them to the API.","title":"4. Test the API"},{"location":"getting-started/deploy-an-api/","text":"Quickstart Now that you've installed Kusk Gateway, let's have a look at how you can use OpenAPI to configure the operational and functional parts of your API. 1. Create an API Manifest Create the file api.yaml apiVersion : gateway.kusk.io/v1alpha1 kind : API metadata : name : hello-world spec : fleet : name : kusk-gateway-envoy-fleet namespace : kusk-system spec : | openapi: 3.0.0 info: title: simple-api version: 0.1.0 x-kusk: cors: origins: - \"*\" methods: - GET mocking: enabled: true paths: /hello: get: responses: '200': description: A simple hello world! content: text/plain: schema: type: string example: Hello from a mocked response! Kusk Gateway relies on OpenAPI to define your APIs and configure the gateway, all in one place, using the x-kusk extension. In this example, we have defined a simple /hello endpoint and configured the gateway (under x-kusk section) enabling CORS and API mocking. 2. Deploy the Gateway Configuration kubectl apply -f api.yaml 3. Test the API Given we have enabled gateway-level mocks, we don't need to implement the services to be able to test the API. Get the External IP of Kusk-gateway as indicated in installing Kusk-gateway section . And query the /hello endpoint $ curl EXTERNAL_IP/hello Hello world! In the next section , we'll cover how to connect your service to Kusk-gateway. Read More Kusk Gateway API manifest . The x-kusk extension . Mocking of APIs with Kusk.","title":"Deploy an OpenAPI definition"},{"location":"getting-started/deploy-an-api/#quickstart","text":"Now that you've installed Kusk Gateway, let's have a look at how you can use OpenAPI to configure the operational and functional parts of your API.","title":"Quickstart"},{"location":"getting-started/deploy-an-api/#1-create-an-api-manifest","text":"Create the file api.yaml apiVersion : gateway.kusk.io/v1alpha1 kind : API metadata : name : hello-world spec : fleet : name : kusk-gateway-envoy-fleet namespace : kusk-system spec : | openapi: 3.0.0 info: title: simple-api version: 0.1.0 x-kusk: cors: origins: - \"*\" methods: - GET mocking: enabled: true paths: /hello: get: responses: '200': description: A simple hello world! content: text/plain: schema: type: string example: Hello from a mocked response! Kusk Gateway relies on OpenAPI to define your APIs and configure the gateway, all in one place, using the x-kusk extension. In this example, we have defined a simple /hello endpoint and configured the gateway (under x-kusk section) enabling CORS and API mocking.","title":"1. Create an API Manifest"},{"location":"getting-started/deploy-an-api/#2-deploy-the-gateway-configuration","text":"kubectl apply -f api.yaml","title":"2. Deploy the Gateway Configuration"},{"location":"getting-started/deploy-an-api/#3-test-the-api","text":"Given we have enabled gateway-level mocks, we don't need to implement the services to be able to test the API. Get the External IP of Kusk-gateway as indicated in installing Kusk-gateway section . And query the /hello endpoint $ curl EXTERNAL_IP/hello Hello world! In the next section , we'll cover how to connect your service to Kusk-gateway.","title":"3. Test the API"},{"location":"getting-started/deploy-an-api/#read-more","text":"Kusk Gateway API manifest . The x-kusk extension . Mocking of APIs with Kusk.","title":"Read More"},{"location":"getting-started/installation/","text":"Installing Kusk Gateway Prerequisites Kubernetes v1.16+ Kubernetes Cluster Administration rights are required - we install CustomResourceDefinitions and a ServiceAccount with ClusterRoles and RoleBindings. Installation requirements Tools needed for the installation: helm command-line tool kubectl command-line tool Installing Kusk Gateway 1. Install Kusk CLI You can find other installation methods (like Homebrew) here . bash < < ( curl -sSLf https://raw.githubusercontent.com/kubeshop/kusk/main/scripts/install.sh ) 2. Install Kusk Gateway Use the Kusk CLIs install command to install Kusk Gateway in your cluster. kusk install 3. Access the Dashboard Kusk Gateway includes a browser-based dashboard for inspection and management of your deployed APIs. Use the following commands to open it in your local browser after the above installation finishes. kubectl port-forward -n kusk-system svc/kusk-gateway-private-envoy-fleet 8080 :80 open http://localhost:8080 Get the Gateway's External IP If you want to access the APIs or StaticRoutes managed by Kusk Gateway, get the External IP address of the Load Balancer by running the command below. Note that it may take a few seconds for the LoadBalancer IP to become available. kubectl get svc -l \"app.kubernetes.io/component=envoy-svc\" --namespace kusk-system The output should contain the Envoy Fleet Service, which is the entry point of your API gateway, with the External-IP address field - use this address for your API endpoints querying. Note that it might take a while for the External IP to be created. !!! note non-important \"External IP might not be available for some cluster setups\". If you are running a **local setup**, you can access the API endpoint with: `kubectl port-forward service/kusk-gateway-envoy-fleet 8088:80 -n kusk-system` If you are running a **bare metal cluster**, consider installing [MetalLB](https://metallb.universe.tf) which creates External IP for LoadBalancer Service type in Kubernetes. If there are any issues, please check the Troubleshooting section.","title":"Installing Kusk Gateway"},{"location":"getting-started/installation/#installing-kusk-gateway","text":"","title":"Installing Kusk Gateway"},{"location":"getting-started/installation/#prerequisites","text":"Kubernetes v1.16+ Kubernetes Cluster Administration rights are required - we install CustomResourceDefinitions and a ServiceAccount with ClusterRoles and RoleBindings.","title":"Prerequisites"},{"location":"getting-started/installation/#installation-requirements","text":"Tools needed for the installation: helm command-line tool kubectl command-line tool","title":"Installation requirements"},{"location":"getting-started/installation/#installing-kusk-gateway_1","text":"","title":"Installing Kusk Gateway"},{"location":"getting-started/installation/#1-install-kusk-cli","text":"You can find other installation methods (like Homebrew) here . bash < < ( curl -sSLf https://raw.githubusercontent.com/kubeshop/kusk/main/scripts/install.sh )","title":"1. Install Kusk CLI"},{"location":"getting-started/installation/#2-install-kusk-gateway","text":"Use the Kusk CLIs install command to install Kusk Gateway in your cluster. kusk install","title":"2. Install Kusk Gateway"},{"location":"getting-started/installation/#3-access-the-dashboard","text":"Kusk Gateway includes a browser-based dashboard for inspection and management of your deployed APIs. Use the following commands to open it in your local browser after the above installation finishes. kubectl port-forward -n kusk-system svc/kusk-gateway-private-envoy-fleet 8080 :80 open http://localhost:8080","title":"3. Access the Dashboard"},{"location":"getting-started/installation/#get-the-gateways-external-ip","text":"If you want to access the APIs or StaticRoutes managed by Kusk Gateway, get the External IP address of the Load Balancer by running the command below. Note that it may take a few seconds for the LoadBalancer IP to become available. kubectl get svc -l \"app.kubernetes.io/component=envoy-svc\" --namespace kusk-system The output should contain the Envoy Fleet Service, which is the entry point of your API gateway, with the External-IP address field - use this address for your API endpoints querying. Note that it might take a while for the External IP to be created. !!! note non-important \"External IP might not be available for some cluster setups\". If you are running a **local setup**, you can access the API endpoint with: `kubectl port-forward service/kusk-gateway-envoy-fleet 8088:80 -n kusk-system` If you are running a **bare metal cluster**, consider installing [MetalLB](https://metallb.universe.tf) which creates External IP for LoadBalancer Service type in Kubernetes. If there are any issues, please check the Troubleshooting section.","title":"Get the Gateway's External IP"},{"location":"guides/basic-auth/","text":"Authentication Currently you can use any Header based authentication methods. This includes: - Basic Authentication - JWT Tokens - Bearer Tokens To set up authentication, add the following section to your x-kusk settings block: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : auth : type : basic auth-upstream : host : hostname : basic-auth-svc.default port:8080 The example above authenticates requests to the whole API. You can also specify different authentication settings for specific operations or paths. The following example shows an example authentication configuration for a specific operation: ... paths : /hello : get : operationId : getHello auth : type : basic auth-upstream : host : hostname : basic-auth-svc.default port:8080 .. In the example, in the hostname section we're referencing an upstream service in our cluster that will handle request authentication. The flow is as follows: hostname can contain any valid domain The hostname field can contain internal cluster domains but also external domains to your cluster that can handle your header based authentication. See all available Authentication configuration options in the Extension Reference .","title":"Basic Auth"},{"location":"guides/basic-auth/#authentication","text":"Currently you can use any Header based authentication methods. This includes: - Basic Authentication - JWT Tokens - Bearer Tokens To set up authentication, add the following section to your x-kusk settings block: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : auth : type : basic auth-upstream : host : hostname : basic-auth-svc.default port:8080 The example above authenticates requests to the whole API. You can also specify different authentication settings for specific operations or paths. The following example shows an example authentication configuration for a specific operation: ... paths : /hello : get : operationId : getHello auth : type : basic auth-upstream : host : hostname : basic-auth-svc.default port:8080 .. In the example, in the hostname section we're referencing an upstream service in our cluster that will handle request authentication. The flow is as follows: hostname can contain any valid domain The hostname field can contain internal cluster domains but also external domains to your cluster that can handle your header based authentication. See all available Authentication configuration options in the Extension Reference .","title":"Authentication"},{"location":"guides/cache/","text":"Caching The HTTP Cache stores a response associated with a request and reuses the stored response for subsequent requests. Caches reduce latency and network traffic, as the response is directly returned from the gateway. Kusk Gateway implements all the complexity of HTTP caching semantics. For more information, read Envoy's HTTP Caching documentation . Kusk makes caching easy to configure using a simple OpenAPI extension: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : cache : enabled : true max_age : 60 .. The example above caches responses to HTTP GET requests for 60 seconds. You can also specify different caching settings for a specific operation or path. The following example shows rate limiting configuration for a specific operation: ... paths : /hello : get : operationId : getHello x-kusk : cache : enabled : true max_age : 60 .. See all available Caching configuration options in the Extension Reference .","title":"Caching"},{"location":"guides/cache/#caching","text":"The HTTP Cache stores a response associated with a request and reuses the stored response for subsequent requests. Caches reduce latency and network traffic, as the response is directly returned from the gateway. Kusk Gateway implements all the complexity of HTTP caching semantics. For more information, read Envoy's HTTP Caching documentation . Kusk makes caching easy to configure using a simple OpenAPI extension: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : cache : enabled : true max_age : 60 .. The example above caches responses to HTTP GET requests for 60 seconds. You can also specify different caching settings for a specific operation or path. The following example shows rate limiting configuration for a specific operation: ... paths : /hello : get : operationId : getHello x-kusk : cache : enabled : true max_age : 60 .. See all available Caching configuration options in the Extension Reference .","title":"Caching"},{"location":"guides/cert-manager/","text":"Using Cert Manager with Kusk Gateway Cert Manager and Kusk Gateway work well together. Cert Manager is a way to easily issue and automatically rotate certificates. Kusk Gateway can be instructed to use those certificates by defining them in your EnvoyFleet . Kusk Gateway will also watch your certificates for updates and will reload the EnvoyFleet config automatically without the need for any manual actions. Install Cert Manager Cert Manager can be installed using the following command which uses the default configuration. kubectl apply -f https://github.com/cert-manager/cert-manager/releases/latest/download/cert-manager.yaml For other installation methods, refer to Cert Manager's installation document . Issue a Certificate To issue a certificate, we need to define an Issuer or ClusterIssuer. This defines which Certificate Authority Cert Manager will be used to issue the certificate. For demonstration purposes, let's use a simple self-signed certificate issuer: kubectl apply -f - <<EOF apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : test-selfsigned namespace : default spec : selfSigned : {} EOF We can now issue a self-signed certificate using this issuer: kubectl apply -f - <<EOF apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : selfsigned-cert namespace : default spec : dnsNames : - example.com secretName : selfsigned-cert-tls issuerRef : name : test-selfsigned EOF Cert manager will react to the creation of this Certificate resource and produce for us a Kubernetes secret that contains the certificate we can use in Kusk Gateway to secure your endpoints with TLS (Transport Layer Security). Fetch the list of secrets to confirm that our certificate was created: \u276f kubectl get secrets NAME TYPE DATA AGE ... selfsigned-cert-tls kubernetes.io/tls 3 103s Describe the secret: \u276f kubectl describe secret selfsigned-cert-tls Name: selfsigned-cert-tls Namespace: default Labels: <none> Annotations: cert-manager.io/alt-names: example.com cert-manager.io/certificate-name: selfsigned-cert cert-manager.io/common-name: cert-manager.io/ip-sans: cert-manager.io/issuer-group: cert-manager.io/issuer-kind: Issuer cert-manager.io/issuer-name: test-selfsigned cert-manager.io/uri-sans: Type: kubernetes.io/tls Data ==== tls.crt: 1021 bytes tls.key: 1679 bytes ca.crt: 1021 bytes Using the Certificate in Kusk Gateway In your EnvoyFleet definition, add the following TLS settings into the spec field: apiVersion: gateway.kusk.io/v1alpha1 kind: EnvoyFleet metadata: name: default spec: ... tls: tlsSecrets: - secretRef: selfsigned-cert-tls namespace: default We defined the hostname in the certificate as example.com, therefore, your API will need to have this host in the hosts array of the x-kusk extension to make use of the secret. We can confirm the details of the certificate using OpenSSL: echo | \\ openssl s_client -servername example.com -connect example.com:443 2 >/dev/null | \\ openssl x509 -text For this example, you will need to add example.com to your /etc/hosts file pointing at the envoy service public IP running in the cluster. Rotating Secrets Kusk Gateway will watch for updates to your secrets in any of its EnvoyFleets and update the config to use them automatically, without any manual intervention needed We can force a certificate rotation using cmctl and then check that Kusk Gateway does register the change and update the config accordingly. You will need to have cmctl installed . Now we can issue a renew command: \u276f cmctl renew selfsigned-cert Manually triggered issuance of Certificate default/selfsigned-cert This will mark the named secret for manual renewal by cert-manager and it should do so relatively quickly. Use OpenSSL again to check the updated certificate: echo | \\ openssl s_client -servername example.com -connect example.com:443 2 >/dev/null | \\ openssl x509 -text","title":"Using Cert Manager"},{"location":"guides/cert-manager/#using-cert-manager-with-kusk-gateway","text":"Cert Manager and Kusk Gateway work well together. Cert Manager is a way to easily issue and automatically rotate certificates. Kusk Gateway can be instructed to use those certificates by defining them in your EnvoyFleet . Kusk Gateway will also watch your certificates for updates and will reload the EnvoyFleet config automatically without the need for any manual actions.","title":"Using Cert Manager with Kusk Gateway"},{"location":"guides/cert-manager/#install-cert-manager","text":"Cert Manager can be installed using the following command which uses the default configuration. kubectl apply -f https://github.com/cert-manager/cert-manager/releases/latest/download/cert-manager.yaml For other installation methods, refer to Cert Manager's installation document .","title":"Install Cert Manager"},{"location":"guides/cert-manager/#issue-a-certificate","text":"To issue a certificate, we need to define an Issuer or ClusterIssuer. This defines which Certificate Authority Cert Manager will be used to issue the certificate. For demonstration purposes, let's use a simple self-signed certificate issuer: kubectl apply -f - <<EOF apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : test-selfsigned namespace : default spec : selfSigned : {} EOF We can now issue a self-signed certificate using this issuer: kubectl apply -f - <<EOF apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : selfsigned-cert namespace : default spec : dnsNames : - example.com secretName : selfsigned-cert-tls issuerRef : name : test-selfsigned EOF Cert manager will react to the creation of this Certificate resource and produce for us a Kubernetes secret that contains the certificate we can use in Kusk Gateway to secure your endpoints with TLS (Transport Layer Security). Fetch the list of secrets to confirm that our certificate was created: \u276f kubectl get secrets NAME TYPE DATA AGE ... selfsigned-cert-tls kubernetes.io/tls 3 103s Describe the secret: \u276f kubectl describe secret selfsigned-cert-tls Name: selfsigned-cert-tls Namespace: default Labels: <none> Annotations: cert-manager.io/alt-names: example.com cert-manager.io/certificate-name: selfsigned-cert cert-manager.io/common-name: cert-manager.io/ip-sans: cert-manager.io/issuer-group: cert-manager.io/issuer-kind: Issuer cert-manager.io/issuer-name: test-selfsigned cert-manager.io/uri-sans: Type: kubernetes.io/tls Data ==== tls.crt: 1021 bytes tls.key: 1679 bytes ca.crt: 1021 bytes","title":"Issue a Certificate"},{"location":"guides/cert-manager/#using-the-certificate-in-kusk-gateway","text":"In your EnvoyFleet definition, add the following TLS settings into the spec field: apiVersion: gateway.kusk.io/v1alpha1 kind: EnvoyFleet metadata: name: default spec: ... tls: tlsSecrets: - secretRef: selfsigned-cert-tls namespace: default We defined the hostname in the certificate as example.com, therefore, your API will need to have this host in the hosts array of the x-kusk extension to make use of the secret. We can confirm the details of the certificate using OpenSSL: echo | \\ openssl s_client -servername example.com -connect example.com:443 2 >/dev/null | \\ openssl x509 -text For this example, you will need to add example.com to your /etc/hosts file pointing at the envoy service public IP running in the cluster.","title":"Using the Certificate in Kusk Gateway"},{"location":"guides/cert-manager/#rotating-secrets","text":"Kusk Gateway will watch for updates to your secrets in any of its EnvoyFleets and update the config to use them automatically, without any manual intervention needed We can force a certificate rotation using cmctl and then check that Kusk Gateway does register the change and update the config accordingly. You will need to have cmctl installed . Now we can issue a renew command: \u276f cmctl renew selfsigned-cert Manually triggered issuance of Certificate default/selfsigned-cert This will mark the named secret for manual renewal by cert-manager and it should do so relatively quickly. Use OpenSSL again to check the updated certificate: echo | \\ openssl s_client -servername example.com -connect example.com:443 2 >/dev/null | \\ openssl x509 -text","title":"Rotating Secrets"},{"location":"guides/cors/","text":"CORS Settings CORS (Cross-Origin Resource Sharing) is a standard implemented by browsers for ensuring that only the allowed clients actually access your API, see https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS . One of the biggest pain-points when deploying your API that is consumed by a browser application is not having the correct CORS configuration on your API Server. Fortunately, Kusk makes configuring CORS for your API easy - add the corresponding CORS extension to your OpenAPI definition at the desired level (usually the root): openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : cors : origins : - \"*\" methods : - POST - GET - OPTIONS headers : - Content-Type credentials : true max_age : 86200 .. If you want to override CORS settings for a specific operation or path you can do so. For example, to change the allowed origins for a specific operation you could add: paths : /hello : get : operationId : getHello x-kusk : cors : origins : - \"gethello.com\" .. See all available CORS configuration options in the Extension Reference .","title":"CORS"},{"location":"guides/cors/#cors-settings","text":"CORS (Cross-Origin Resource Sharing) is a standard implemented by browsers for ensuring that only the allowed clients actually access your API, see https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS . One of the biggest pain-points when deploying your API that is consumed by a browser application is not having the correct CORS configuration on your API Server. Fortunately, Kusk makes configuring CORS for your API easy - add the corresponding CORS extension to your OpenAPI definition at the desired level (usually the root): openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : cors : origins : - \"*\" methods : - POST - GET - OPTIONS headers : - Content-Type credentials : true max_age : 86200 .. If you want to override CORS settings for a specific operation or path you can do so. For example, to change the allowed origins for a specific operation you could add: paths : /hello : get : operationId : getHello x-kusk : cors : origins : - \"gethello.com\" .. See all available CORS configuration options in the Extension Reference .","title":"CORS Settings"},{"location":"guides/mocking/","text":"Response Mocking How can Mocking help? Mocking is an integral part of the API lifecycle. Providing mocks can help both API consumers (for example, FE/Mobile app developers) and testers to bootstrap their efforts without being dependent on the actual implementation of an API being available. It can also help prototype API integrations and validate API designs with end-users before actually implementing them. How does Mocking work? Kusk Gateway makes mocking of your APIs extremely easy; simply add the x-kusk.mocking property to your API (globally or at any other level) to enable the mocking of responses using the examples provided in an OpenAPI definition - examples object . Either example: (singular) or examples: (plural) are supported, however with multiple objects in examples , the response will include only one from that object map. If both are specified, singular ( example ) has the priority over plural. Examples are defined as a part of the response HTTP code and its contents' media-type (e.g. application/json ) and could be different for the different media types. As part of the mocked response, the related HTTP code is returned, but only success codes are supported for the mocking. For example, 200 and 201, but not 400, 404 or 500. Though the OpenAPI standard allows the response code to be a range or a wildcard (e.g. \"2xx\"), we need to know exactly what code to return, so this should be specified exactly as integer compatible (\"200\"). In case the response doesn't have the response schema, only the single http code is used to mock the response, the body is not returned. This is useful to test, for example, DELETE or PATCH operations that don't produce the body. mocking is inheritable - if it is specified on the path or root level it will include every operation below it. In case there are responses without the response schema but with the examples, these must be explicitly disabled with mocking.enabled: false , otherwise the configuration submission will fail. Note: Currently mocking is incompatible with the validation option, the configuration deployment will fail if both are enabled. Mocking Example Consider the following operation in an OpenAPI definition: /mocked/{id} : # Enable mocking with x-kusk # Will enable mocking for all HTTP operations below x-kusk : mocking : enabled : true get : responses : # This HTTP code will be returned. '200' : description : 'Mocked ToDos' content : application/json : schema : type : object properties : title : type : string description : Description of what to do completed : type : boolean order : type : integer format : int32 url : type : string required : - title - completed - order - url # Singular example has the priority over other examples. example : title : \"Mocked JSON title\" completed : true order : 13 url : \"http://mockedURL.com\" examples : first : title : \"Mocked JSON title #1\" completed : true order : 12 url : \"http://mockedURL.com\" second : title : \"Mocked JSON title #2\" completed : true order : 13 url : \"http://mockedURL.com\" application/xml : example : title : \"Mocked XML title\" completed : true order : 13 url : \"http://mockedURL.com\" text/plain : example : | title: \"Mocked Text title\" completed: true order: 13 url: \"http://mockedURL.com\" patch : # Disable for patch x-kusk : mocking : enabled : false ... With the example above, the response to the GET request will be different depending on the client's preferred media type when using the Accept header. Below, we're using the example.com setup from the development/testing directory. Curl call without specifying the Accept header: From the list of specified media types (application/json, plain/text, application/xml), this example uses our default Mocking media type - application/json: curl -v -H \"Host: example.com\" http://192.168.49.3/testing/mocked/multiple/1 < HTTP/1.1 200 OK < content-type: application/json < x-kusk-mocked: true < date: Mon, 21 Feb 2022 14 :36:52 GMT < content-length: 81 < x-envoy-upstream-service-time: 0 < server: envoy < { \"completed\" :true, \"order\" :13, \"title\" : \"Mocked JSON title\" , \"url\" : \"http://mockedURL.com\" } The response includes the x-kusk-mocked: true header indicating mocking. With the Accept header, that has application/xml as the preferred type: curl -v -H \"Host: example.com\" -H \"Accept: application/xml\" http://192.168.49.3/testing/mocked/1 < HTTP/1.1 200 OK < content-type: application/xml < x-kusk-mocked: true < date: Mon, 28 Feb 2022 08 :56:46 GMT < content-length: 117 < x-envoy-upstream-service-time: 0 < server: envoy <doc><completed>true</completed><order>13</order><title>Mocked XML title</title><url>http://mockedURL.com</url></doc> With the Accept header specifying multiple weighted preferred media types, text/plain with more weight. curl -v -H \"Host: example.com\" -H \"Accept: application/json;q=0.8,text/plain;q=0.9\" http://192.168.49.3/testing/mocked/1 < content-type: text/plain < x-kusk-mocked: true < date: Mon, 28 Feb 2022 08 :56:00 GMT < content-length: 81 < x-envoy-upstream-service-time: 0 < server: envoy < title: \"Mocked Text title\" completed: true order: 13 url: \"http://mockedURL.com\"","title":"Mocking"},{"location":"guides/mocking/#response-mocking","text":"","title":"Response Mocking"},{"location":"guides/mocking/#how-can-mocking-help","text":"Mocking is an integral part of the API lifecycle. Providing mocks can help both API consumers (for example, FE/Mobile app developers) and testers to bootstrap their efforts without being dependent on the actual implementation of an API being available. It can also help prototype API integrations and validate API designs with end-users before actually implementing them.","title":"How can Mocking help?"},{"location":"guides/mocking/#how-does-mocking-work","text":"Kusk Gateway makes mocking of your APIs extremely easy; simply add the x-kusk.mocking property to your API (globally or at any other level) to enable the mocking of responses using the examples provided in an OpenAPI definition - examples object . Either example: (singular) or examples: (plural) are supported, however with multiple objects in examples , the response will include only one from that object map. If both are specified, singular ( example ) has the priority over plural. Examples are defined as a part of the response HTTP code and its contents' media-type (e.g. application/json ) and could be different for the different media types. As part of the mocked response, the related HTTP code is returned, but only success codes are supported for the mocking. For example, 200 and 201, but not 400, 404 or 500. Though the OpenAPI standard allows the response code to be a range or a wildcard (e.g. \"2xx\"), we need to know exactly what code to return, so this should be specified exactly as integer compatible (\"200\"). In case the response doesn't have the response schema, only the single http code is used to mock the response, the body is not returned. This is useful to test, for example, DELETE or PATCH operations that don't produce the body. mocking is inheritable - if it is specified on the path or root level it will include every operation below it. In case there are responses without the response schema but with the examples, these must be explicitly disabled with mocking.enabled: false , otherwise the configuration submission will fail. Note: Currently mocking is incompatible with the validation option, the configuration deployment will fail if both are enabled.","title":"How does Mocking work?"},{"location":"guides/mocking/#mocking-example","text":"Consider the following operation in an OpenAPI definition: /mocked/{id} : # Enable mocking with x-kusk # Will enable mocking for all HTTP operations below x-kusk : mocking : enabled : true get : responses : # This HTTP code will be returned. '200' : description : 'Mocked ToDos' content : application/json : schema : type : object properties : title : type : string description : Description of what to do completed : type : boolean order : type : integer format : int32 url : type : string required : - title - completed - order - url # Singular example has the priority over other examples. example : title : \"Mocked JSON title\" completed : true order : 13 url : \"http://mockedURL.com\" examples : first : title : \"Mocked JSON title #1\" completed : true order : 12 url : \"http://mockedURL.com\" second : title : \"Mocked JSON title #2\" completed : true order : 13 url : \"http://mockedURL.com\" application/xml : example : title : \"Mocked XML title\" completed : true order : 13 url : \"http://mockedURL.com\" text/plain : example : | title: \"Mocked Text title\" completed: true order: 13 url: \"http://mockedURL.com\" patch : # Disable for patch x-kusk : mocking : enabled : false ... With the example above, the response to the GET request will be different depending on the client's preferred media type when using the Accept header. Below, we're using the example.com setup from the development/testing directory. Curl call without specifying the Accept header: From the list of specified media types (application/json, plain/text, application/xml), this example uses our default Mocking media type - application/json: curl -v -H \"Host: example.com\" http://192.168.49.3/testing/mocked/multiple/1 < HTTP/1.1 200 OK < content-type: application/json < x-kusk-mocked: true < date: Mon, 21 Feb 2022 14 :36:52 GMT < content-length: 81 < x-envoy-upstream-service-time: 0 < server: envoy < { \"completed\" :true, \"order\" :13, \"title\" : \"Mocked JSON title\" , \"url\" : \"http://mockedURL.com\" } The response includes the x-kusk-mocked: true header indicating mocking. With the Accept header, that has application/xml as the preferred type: curl -v -H \"Host: example.com\" -H \"Accept: application/xml\" http://192.168.49.3/testing/mocked/1 < HTTP/1.1 200 OK < content-type: application/xml < x-kusk-mocked: true < date: Mon, 28 Feb 2022 08 :56:46 GMT < content-length: 117 < x-envoy-upstream-service-time: 0 < server: envoy <doc><completed>true</completed><order>13</order><title>Mocked XML title</title><url>http://mockedURL.com</url></doc> With the Accept header specifying multiple weighted preferred media types, text/plain with more weight. curl -v -H \"Host: example.com\" -H \"Accept: application/json;q=0.8,text/plain;q=0.9\" http://192.168.49.3/testing/mocked/1 < content-type: text/plain < x-kusk-mocked: true < date: Mon, 28 Feb 2022 08 :56:00 GMT < content-length: 81 < x-envoy-upstream-service-time: 0 < server: envoy < title: \"Mocked Text title\" completed: true order: 13 url: \"http://mockedURL.com\"","title":"Mocking Example"},{"location":"guides/observability/","text":"Observability Envoy Admin Interface Envoy's admin interface is opened on 19000 port and could be used for troubleshooting, configuration dumps, changing logs levels and other administrative tasks. Refer to the Troubleshooting on the usage. Metrics Envoy exposes a Stats service on the admin interface. Currently, we don't configure any stats sinks to publish the metrics, but Prometheus can discover Envoy pods and query them for the metrics, if pods have the following annotations: annotations : prometheus.io/scrape : 'true' prometheus.io/port : '19000' prometheus.io/path : /stats/prometheus This can be configured with EnvoyFleet Custom resource spec.annotations field. The list of exported HTTP metrics is described in HTTP Connection Manager Statistics . See also Listener Metrics .","title":"Observability"},{"location":"guides/observability/#observability","text":"","title":"Observability"},{"location":"guides/observability/#envoy-admin-interface","text":"Envoy's admin interface is opened on 19000 port and could be used for troubleshooting, configuration dumps, changing logs levels and other administrative tasks. Refer to the Troubleshooting on the usage.","title":"Envoy Admin Interface"},{"location":"guides/observability/#metrics","text":"Envoy exposes a Stats service on the admin interface. Currently, we don't configure any stats sinks to publish the metrics, but Prometheus can discover Envoy pods and query them for the metrics, if pods have the following annotations: annotations : prometheus.io/scrape : 'true' prometheus.io/port : '19000' prometheus.io/path : /stats/prometheus This can be configured with EnvoyFleet Custom resource spec.annotations field. The list of exported HTTP metrics is described in HTTP Connection Manager Statistics . See also Listener Metrics .","title":"Metrics"},{"location":"guides/rate-limit/","text":"Rate limiting Rate limiting ensures that your application doesn't get more than a specified number of requests over time. It effectively helps to protect your API from overloading. For requests above the threshold, Kusk Gateway returns HTTP Too Many Requests error. Kusk makes it easy to configure Rate Limiting, using the rate_limit option in the x-kusk extension: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : rate_limit : requests_per_unit : 2 unit : minute .. The example above allows only up to two requests per minute to be sent to the whole API. You can also specify different rate-limiting settings for a specific operation or path. The following example shows rate limiting configuration for a specific operation: ... paths : /hello : get : operationId : getHello x-kusk : rate_limit : requests_per_unit : 2 unit : minute .. See all available Rate Limiting configuration options in the Extension Reference .","title":"Rate Limiting"},{"location":"guides/rate-limit/#rate-limiting","text":"Rate limiting ensures that your application doesn't get more than a specified number of requests over time. It effectively helps to protect your API from overloading. For requests above the threshold, Kusk Gateway returns HTTP Too Many Requests error. Kusk makes it easy to configure Rate Limiting, using the rate_limit option in the x-kusk extension: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : rate_limit : requests_per_unit : 2 unit : minute .. The example above allows only up to two requests per minute to be sent to the whole API. You can also specify different rate-limiting settings for a specific operation or path. The following example shows rate limiting configuration for a specific operation: ... paths : /hello : get : operationId : getHello x-kusk : rate_limit : requests_per_unit : 2 unit : minute .. See all available Rate Limiting configuration options in the Extension Reference .","title":"Rate limiting"},{"location":"guides/routing/","text":"Request Routing Incoming requests to Kusk Gateway can be routed to the target service in two ways: Forwarded to an actual service in your cluster using the upstream property. Redirected to a different endpoint using the redirect property. Furthermore, two properties are available to distinguish to which of these an incoming request should go: The hosts property allows you to define to which hostname(s) a specific API answers. The path property allows you to configure a base path for the exposed API. Any of these properties can be specified at the root, path, or operation level in your OpenAPI definition, allowing you to route separate operations differently. For example, not all operations might be handled by the same service, in which case you could define different upstream services accordingly. Forwarding Requests to a Service in your Cluster This will be the most common scenario - incoming requests to Kusk Gateway will be forward to a service or host running in your cluster: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : upstream : service : name : simple-api-service namespace : default .. Here all requests are sent to the simple-api-service in the default namespace on the default port (80). If we had a different service for one of the operations, we could override this at the operation level: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : upstream : service : name : simple-api-service namespace : default port : 8001 path : /someoperation : get : operationId : doSomething x-kusk : upstream : service : name : another-service port : 8080 .. Here the default service is listening on port 8001 and we have specified a different service for the doSomething operation, still in the same namespace but also on a different port. If we instead wanted to route default API requests to different hostname, instead of a specific service, we could do something like: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : upstream : host : hostname : simple-api-service-hostname port : 8001 .. Also, we could override this routing at the operation level as before: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : upstream : host : hostname : simple-api-service-hostname port : 8001 path : /someoperation : get : operationId : doSomething x-kusk : upstream : service : name : another-service port : 8080 .. Rewriting Request Paths The optional rewrite property allows us to modify the path of the request before forwarding it to the upstream service. For example, if we have a service foo with a single endpoint /bar , we configure Kusk Gateway to forward traffic to the foo service when it receives traffic on a path with the prefix /foo . If we receive a request at /foo/bar , the request will be forwarded to the foo service. foo will throw a 404 error as it doesn't have a path /foo/bar . Therefore, we must rewrite the path from /foo/bar to /bar before sending it onto the foo service. The following config extract will allow us to do this: upstream : service : ... # /foo/bar/... -> to upstream: /bar/... rewrite : pattern : \"^/foo\" substitution : \"\" See all available upstream configuration options in the Extension Reference . Redirecting Requests to a Different Host/Path Instead of forwarding requests to a service or hostname in our cluster, we might want to redirect the client to a totally different URL, for example, when: The API has moved to a different host. Individual operations have been renamed. The redirect property allows us to do this. First, redirect to a different host: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : redirect : scheme_redirect : https host_redirect : thenewhost.com response_code : 302 .. This would redirect any requests to the API to the specified host using a 302 HTTP response. As indicated above we could use this property to redirect individual operations: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : upstream : host : simple-api-service-hostname port : 8001 path : /newoperation : get : operationId : doSomething .. /oldoperation : x-kusk : redirect : path_redirect : /newoperation .. This can be helpful when operations have been renamed during a major version update or if we want to deprecate an operation: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : upstream : host : hostname : simple-api-service-hostname port : 8001 path : /someoperation : get : operationId : doSomething .. put : x-kusk : redirect : scheme_redirect : https host_redirect : mywebsite.com path_redirect : /deprecated.html .. See all available redirect configuration options in the Extension Reference . Specifying an External Path for Your API Often you will want to prefix your API path with something like \"/api\" externally, although your internal API implementation is running on the root path \"/\". Kusk allows you to specify a path.prefix property for this, which you can use together with the rewrite described above in this scenario: x-kusk : path : prefix : /api upstream : service : ... # /api/bar/... -> to upstream: /bar/... rewrite : pattern : \"^/api\" substitution : \"\" Using Hosts for Multi-hosting Scenarios In a multi-hosting scenario for a single IP, you might want to ensure that requests to different hosts go to different APIs: https://onehost.com/api -> api nr 1 https://anotherhost.com/api -> api nr 2 You can use the hosts property for this: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : upstream : service : simple-api-service namespace : default hosts : - onehost.com .. Now, only requests to the onehost.com host will get forward to the simple-api-service. Disabling Operations In certain situations, your OpenAPI definition might contain operations that you do not want exposed to API consumers, for example, if these are still in development or if they are meant to be consumed internally only. Kusk Gateway provides a x-kusk.disabled property for this purpose, which can be set at the global, path or operation level. For example, if we wanted to disable the PUT operation in one of our examples above we could add this extension: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : upstream : host : hostname : simple-api-service-hostname port : 8001 path : /someoperation : get : operationId : doSomething .. put : x-kusk : disabled : true Setting this property to true at the top level will hide all operations, allowing you to override this property at the path or operation level when you want to expose only specific operations.","title":"Routing & Disabling"},{"location":"guides/routing/#request-routing","text":"Incoming requests to Kusk Gateway can be routed to the target service in two ways: Forwarded to an actual service in your cluster using the upstream property. Redirected to a different endpoint using the redirect property. Furthermore, two properties are available to distinguish to which of these an incoming request should go: The hosts property allows you to define to which hostname(s) a specific API answers. The path property allows you to configure a base path for the exposed API. Any of these properties can be specified at the root, path, or operation level in your OpenAPI definition, allowing you to route separate operations differently. For example, not all operations might be handled by the same service, in which case you could define different upstream services accordingly.","title":"Request Routing"},{"location":"guides/routing/#forwarding-requests-to-a-service-in-your-cluster","text":"This will be the most common scenario - incoming requests to Kusk Gateway will be forward to a service or host running in your cluster: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : upstream : service : name : simple-api-service namespace : default .. Here all requests are sent to the simple-api-service in the default namespace on the default port (80). If we had a different service for one of the operations, we could override this at the operation level: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : upstream : service : name : simple-api-service namespace : default port : 8001 path : /someoperation : get : operationId : doSomething x-kusk : upstream : service : name : another-service port : 8080 .. Here the default service is listening on port 8001 and we have specified a different service for the doSomething operation, still in the same namespace but also on a different port. If we instead wanted to route default API requests to different hostname, instead of a specific service, we could do something like: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : upstream : host : hostname : simple-api-service-hostname port : 8001 .. Also, we could override this routing at the operation level as before: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : upstream : host : hostname : simple-api-service-hostname port : 8001 path : /someoperation : get : operationId : doSomething x-kusk : upstream : service : name : another-service port : 8080 ..","title":"Forwarding Requests to a Service in your Cluster"},{"location":"guides/routing/#rewriting-request-paths","text":"The optional rewrite property allows us to modify the path of the request before forwarding it to the upstream service. For example, if we have a service foo with a single endpoint /bar , we configure Kusk Gateway to forward traffic to the foo service when it receives traffic on a path with the prefix /foo . If we receive a request at /foo/bar , the request will be forwarded to the foo service. foo will throw a 404 error as it doesn't have a path /foo/bar . Therefore, we must rewrite the path from /foo/bar to /bar before sending it onto the foo service. The following config extract will allow us to do this: upstream : service : ... # /foo/bar/... -> to upstream: /bar/... rewrite : pattern : \"^/foo\" substitution : \"\" See all available upstream configuration options in the Extension Reference .","title":"Rewriting Request Paths"},{"location":"guides/routing/#redirecting-requests-to-a-different-hostpath","text":"Instead of forwarding requests to a service or hostname in our cluster, we might want to redirect the client to a totally different URL, for example, when: The API has moved to a different host. Individual operations have been renamed. The redirect property allows us to do this. First, redirect to a different host: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : redirect : scheme_redirect : https host_redirect : thenewhost.com response_code : 302 .. This would redirect any requests to the API to the specified host using a 302 HTTP response. As indicated above we could use this property to redirect individual operations: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : upstream : host : simple-api-service-hostname port : 8001 path : /newoperation : get : operationId : doSomething .. /oldoperation : x-kusk : redirect : path_redirect : /newoperation .. This can be helpful when operations have been renamed during a major version update or if we want to deprecate an operation: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : upstream : host : hostname : simple-api-service-hostname port : 8001 path : /someoperation : get : operationId : doSomething .. put : x-kusk : redirect : scheme_redirect : https host_redirect : mywebsite.com path_redirect : /deprecated.html .. See all available redirect configuration options in the Extension Reference .","title":"Redirecting Requests to a Different Host/Path"},{"location":"guides/routing/#specifying-an-external-path-for-your-api","text":"Often you will want to prefix your API path with something like \"/api\" externally, although your internal API implementation is running on the root path \"/\". Kusk allows you to specify a path.prefix property for this, which you can use together with the rewrite described above in this scenario: x-kusk : path : prefix : /api upstream : service : ... # /api/bar/... -> to upstream: /bar/... rewrite : pattern : \"^/api\" substitution : \"\"","title":"Specifying an External Path for Your API"},{"location":"guides/routing/#using-hosts-for-multi-hosting-scenarios","text":"In a multi-hosting scenario for a single IP, you might want to ensure that requests to different hosts go to different APIs: https://onehost.com/api -> api nr 1 https://anotherhost.com/api -> api nr 2 You can use the hosts property for this: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : upstream : service : simple-api-service namespace : default hosts : - onehost.com .. Now, only requests to the onehost.com host will get forward to the simple-api-service.","title":"Using Hosts for Multi-hosting Scenarios"},{"location":"guides/routing/#disabling-operations","text":"In certain situations, your OpenAPI definition might contain operations that you do not want exposed to API consumers, for example, if these are still in development or if they are meant to be consumed internally only. Kusk Gateway provides a x-kusk.disabled property for this purpose, which can be set at the global, path or operation level. For example, if we wanted to disable the PUT operation in one of our examples above we could add this extension: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : upstream : host : hostname : simple-api-service-hostname port : 8001 path : /someoperation : get : operationId : doSomething .. put : x-kusk : disabled : true Setting this property to true at the top level will hide all operations, allowing you to override this property at the path or operation level when you want to expose only specific operations.","title":"Disabling Operations"},{"location":"guides/timeouts/","text":"Request Timeouts Kusk Gateway makes it easy to specify timeouts for your API operations, both globally and individually, for each path or operation. For example the API below defines a global 60-second request timeout, which is overridden for the getHello operation and set to 10 seconds: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : qos : request_timeout : 60 paths : /hello : get : operationId : getHello x-kusk : qos : request_timeout : 10 .. See all available timeout configuration options in the Extension Reference .","title":"Timeouts"},{"location":"guides/timeouts/#request-timeouts","text":"Kusk Gateway makes it easy to specify timeouts for your API operations, both globally and individually, for each path or operation. For example the API below defines a global 60-second request timeout, which is overridden for the getHello operation and set to 10 seconds: openapi : 3.0.0 info : title : simple-api version : 0.1.0 x-kusk : qos : request_timeout : 60 paths : /hello : get : operationId : getHello x-kusk : qos : request_timeout : 10 .. See all available timeout configuration options in the Extension Reference .","title":"Request Timeouts"},{"location":"guides/troubleshooting/","text":"Troubleshooting To see what routes are set up on the gateway: 1. Get the name of your envoy fleet deployment. \u276f kubectl get deployment -n kusk-system NAME READY UP-TO-DATE AVAILABLE AGE kusk-gateway-manager 1/1 1 1 15m kusk-gateway-envoy-default 1/1 1 1 2m33s For this example, it's kusk-envoy-default . Be sure to query the correct namespace for your installation. 2. Port forward to the envoy deployment on port 19000. The admin console is configured to listen on port 19000, so we will port forward to it: \u276f kubectl port-forward deployment/kusk-envoy-default -n kusk-system 19000 Forwarding from 127.0.0.1:19000 -> 19000 Forwarding from [::1]:19000 -> 19000 Handling connection for 19000 3. Hit localhost:19000/config_dump in your browser. 4. Alternatively, use curl and jq to query routes. curl http://localhost:19000/config_dump | jq '.configs[] | select(.[\"@type\"] == \"type.googleapis.com/envoy.admin.v3.RoutesConfigDump\") | .dynamic_route_configs[].route_config.virtual_hosts[].routes[]' If the command hangs at all, cancel it and run it again. Webhooks Timeouts During Deployment You may encounter an error during the resources' deployment with kubectl like: Error from server ( InternalError ) : error when creating \"examples/todomvc/kusk-backend-api.yaml\" : Internal error occurred: failed calling webhook \"mapi.kb.io\" : failed to call webhook: Post \"https://kusk-gateway-webhooks-service.kusk-system.svc:443/mutate-gateway-kusk-io-v1alpha1-api?timeout=10s\" : context deadline exceeded This means that K8s masters control plane can't call the webhooks service residing on Kusk Gateway Manager on TCP port 9443. This problem is not specific to Kusk Gateway Manager itself and is related to the configuration of your cluster and the firewall rules. To resolve this, in your firewall settings, add port 9443 to the rule containing the list of ports allowed to be accessed by K8s masters control plane.","title":"Troubleshooting"},{"location":"guides/troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"guides/troubleshooting/#to-see-what-routes-are-set-up-on-the-gateway","text":"","title":"To see what routes are set up on the gateway:"},{"location":"guides/troubleshooting/#1-get-the-name-of-your-envoy-fleet-deployment","text":"\u276f kubectl get deployment -n kusk-system NAME READY UP-TO-DATE AVAILABLE AGE kusk-gateway-manager 1/1 1 1 15m kusk-gateway-envoy-default 1/1 1 1 2m33s For this example, it's kusk-envoy-default . Be sure to query the correct namespace for your installation.","title":"1. Get the name of your envoy fleet deployment."},{"location":"guides/troubleshooting/#2-port-forward-to-the-envoy-deployment-on-port-19000","text":"The admin console is configured to listen on port 19000, so we will port forward to it: \u276f kubectl port-forward deployment/kusk-envoy-default -n kusk-system 19000 Forwarding from 127.0.0.1:19000 -> 19000 Forwarding from [::1]:19000 -> 19000 Handling connection for 19000","title":"2. Port forward to the envoy deployment on port 19000."},{"location":"guides/troubleshooting/#3-hit-localhost19000config_dump-in-your-browser","text":"","title":"3. Hit localhost:19000/config_dump in your browser."},{"location":"guides/troubleshooting/#4-alternatively-use-curl-and-jq-to-query-routes","text":"curl http://localhost:19000/config_dump | jq '.configs[] | select(.[\"@type\"] == \"type.googleapis.com/envoy.admin.v3.RoutesConfigDump\") | .dynamic_route_configs[].route_config.virtual_hosts[].routes[]' If the command hangs at all, cancel it and run it again.","title":"4. Alternatively, use curl and jq to query routes."},{"location":"guides/troubleshooting/#webhooks-timeouts-during-deployment","text":"You may encounter an error during the resources' deployment with kubectl like: Error from server ( InternalError ) : error when creating \"examples/todomvc/kusk-backend-api.yaml\" : Internal error occurred: failed calling webhook \"mapi.kb.io\" : failed to call webhook: Post \"https://kusk-gateway-webhooks-service.kusk-system.svc:443/mutate-gateway-kusk-io-v1alpha1-api?timeout=10s\" : context deadline exceeded This means that K8s masters control plane can't call the webhooks service residing on Kusk Gateway Manager on TCP port 9443. This problem is not specific to Kusk Gateway Manager itself and is related to the configuration of your cluster and the firewall rules. To resolve this, in your firewall settings, add port 9443 to the rule containing the list of ports allowed to be accessed by K8s masters control plane.","title":"Webhooks Timeouts During Deployment"},{"location":"guides/validation/","text":"Request Validation Validating request payloads and providing meaningful error messages to consumers of an API can go a long way to provide a better developer experience. Instead of just receiving a 40X response without further details, it can help immensely to know what was actually wrong in the payload - missing properties? incorrect formatting? etc. Writing the code on the server is tedious and often overlooked, making it harder for both consumers and testers to resolve issues they might have when working with your API. Kusk Gateway provides end-user friendly validation against the provided OpenAPI definition automatically, without requiring the implementer of the API to write any code, saving development time for both BE and API consumers. Enabling validation is straight-forward - simply add the corresponding x-kusk property to your OpenAPI definition: x-kusk : validation : request : enabled : Adding this at the global level will ensure all incoming requests are validated against the corresponding OpenAPI definition in regard to request parameters and payload. If the request does not match the specified metadata, a meaningful error is returned to the user without any request being forward to your actual API implementation. Another positive side effect of this functionality is that it provides a \"security-gate\" for your API; malicious requests that are outside your defined operations will not reach the target service where they could do potential harm. See all available validation configuration options in the Extension Reference . Strict Validation of Request Bodies Strict validation means that the request body must conform exactly to the schema specified in your OpenAPI spec. Any fields not in the schema will cause the validation to fail the request/response. To enable this, please add the following field to your schema block if the request body is of type object : paths : /todos/{id} : ... patch : ... requestBody : content : application/json : schema : type : object # if you want strict validation of request bodies, please enable this option in your OpenAPI file additionalProperties : false properties : title : type : string completed : type : boolean order : type : integer format : int32l Note: Currently, mocking is incompatible with the validation option, the configuration deployment will fail if both are enabled.","title":"Validation"},{"location":"guides/validation/#request-validation","text":"Validating request payloads and providing meaningful error messages to consumers of an API can go a long way to provide a better developer experience. Instead of just receiving a 40X response without further details, it can help immensely to know what was actually wrong in the payload - missing properties? incorrect formatting? etc. Writing the code on the server is tedious and often overlooked, making it harder for both consumers and testers to resolve issues they might have when working with your API. Kusk Gateway provides end-user friendly validation against the provided OpenAPI definition automatically, without requiring the implementer of the API to write any code, saving development time for both BE and API consumers. Enabling validation is straight-forward - simply add the corresponding x-kusk property to your OpenAPI definition: x-kusk : validation : request : enabled : Adding this at the global level will ensure all incoming requests are validated against the corresponding OpenAPI definition in regard to request parameters and payload. If the request does not match the specified metadata, a meaningful error is returned to the user without any request being forward to your actual API implementation. Another positive side effect of this functionality is that it provides a \"security-gate\" for your API; malicious requests that are outside your defined operations will not reach the target service where they could do potential harm. See all available validation configuration options in the Extension Reference .","title":"Request Validation"},{"location":"guides/validation/#strict-validation-of-request-bodies","text":"Strict validation means that the request body must conform exactly to the schema specified in your OpenAPI spec. Any fields not in the schema will cause the validation to fail the request/response. To enable this, please add the following field to your schema block if the request body is of type object : paths : /todos/{id} : ... patch : ... requestBody : content : application/json : schema : type : object # if you want strict validation of request bodies, please enable this option in your OpenAPI file additionalProperties : false properties : title : type : string completed : type : boolean order : type : integer format : int32l Note: Currently, mocking is incompatible with the validation option, the configuration deployment will fail if both are enabled.","title":"Strict Validation of Request Bodies"},{"location":"guides/working-with-extension/","text":"The Kusk OpenAPI Extension Kusk Gateway comes with an x-kusk OpenAPI extension to allow an OpenAPI definition to be the source of truth for both operational and functional aspects of your APIs. The extension reference describes all available properties and the following guides are available to help you make the most of them: Mocking - How to mock all or parts of your API. Validation - How work with automatic request validation. CORS - How to specify CORS settings. Routing - How to configure routing of API requests. Timeouts - How to set request timeouts. Properties Overview x-kusk extension can be applied at (not exclusively): Top level of an OpenAPI definition: openapi : 3.0.2 info : title : Swagger Petstore - OpenAPI 3.0 x-kusk : hosts : - \"example.org\" disabled : false cors : ... Path level: openapi : 3.0.2 info : title : Swagger Petstore - OpenAPI 3.0 paths : /pet : x-kusk : disabled : true # disables all /pet endpoints post : ... Method (operation) level: openapi : 3.0.2 info : title : Swagger Petstore - OpenAPI 3.0 paths : /pet : post : x-kusk : upstream : # routes the POST /pet endpoint to a Kubernetes service service : namespace : default name : petstore port : 8000 ... Property Overriding/Inheritance The x-kusk extension at the operation level takes precedence, or overrides, what is specified at the path level, including the disabled option. Likewise, the path level settings override what is specified at the global level. If settings aren't specified at a path or operation level, they will be inherited from the layer above, (Operation > Path > Global).","title":"OpenAPI Extension"},{"location":"guides/working-with-extension/#the-kusk-openapi-extension","text":"Kusk Gateway comes with an x-kusk OpenAPI extension to allow an OpenAPI definition to be the source of truth for both operational and functional aspects of your APIs. The extension reference describes all available properties and the following guides are available to help you make the most of them: Mocking - How to mock all or parts of your API. Validation - How work with automatic request validation. CORS - How to specify CORS settings. Routing - How to configure routing of API requests. Timeouts - How to set request timeouts.","title":"The Kusk OpenAPI Extension"},{"location":"guides/working-with-extension/#properties-overview","text":"x-kusk extension can be applied at (not exclusively): Top level of an OpenAPI definition: openapi : 3.0.2 info : title : Swagger Petstore - OpenAPI 3.0 x-kusk : hosts : - \"example.org\" disabled : false cors : ... Path level: openapi : 3.0.2 info : title : Swagger Petstore - OpenAPI 3.0 paths : /pet : x-kusk : disabled : true # disables all /pet endpoints post : ... Method (operation) level: openapi : 3.0.2 info : title : Swagger Petstore - OpenAPI 3.0 paths : /pet : post : x-kusk : upstream : # routes the POST /pet endpoint to a Kubernetes service service : namespace : default name : petstore port : 8000 ...","title":"Properties Overview"},{"location":"guides/working-with-extension/#property-overridinginheritance","text":"The x-kusk extension at the operation level takes precedence, or overrides, what is specified at the path level, including the disabled option. Likewise, the path level settings override what is specified at the global level. If settings aren't specified at a path or operation level, they will be inherited from the layer above, (Operation > Path > Global).","title":"Property Overriding/Inheritance"},{"location":"reference/architecture/","text":"Architecture Under the hood, Kusk Gateway consists of an Operator (Kusk Gateway Manager) and k8s resources, created and managed by the operator, e.g. APIs, Static Routes and Envoy Fleets. Envoy Proxy is deployed by Kusk Gateway Manager as part of Envoy Fleet Custom Resource configuration that describes K8s Envoy Proxy deployment and its K8s service. Usually this service is of type LoadBalancer, thus exposing the service to the world. Multiple Envoy Fleets can be deployed in the scenario when multiple heterogenous services exist on different IP addresses. Once Envoy Fleet is deployed, Envoy processes connect to the Kusk Gateway Manager for the dynamically updated configuration via GRPC. Kusk Gateway Manager accepts CustomResourceDefinitions API and Static Route to configure the routing deployed in the K8s applications services and updates the related Envoy Fleets routing configuration.","title":"Architecture"},{"location":"reference/architecture/#architecture","text":"Under the hood, Kusk Gateway consists of an Operator (Kusk Gateway Manager) and k8s resources, created and managed by the operator, e.g. APIs, Static Routes and Envoy Fleets. Envoy Proxy is deployed by Kusk Gateway Manager as part of Envoy Fleet Custom Resource configuration that describes K8s Envoy Proxy deployment and its K8s service. Usually this service is of type LoadBalancer, thus exposing the service to the world. Multiple Envoy Fleets can be deployed in the scenario when multiple heterogenous services exist on different IP addresses. Once Envoy Fleet is deployed, Envoy processes connect to the Kusk Gateway Manager for the dynamically updated configuration via GRPC. Kusk Gateway Manager accepts CustomResourceDefinitions API and Static Route to configure the routing deployed in the K8s applications services and updates the related Envoy Fleets routing configuration.","title":"Architecture"},{"location":"reference/extension/","text":"OpenAPI Extension Reference Kusk Gateway comes with an OpenAPI extension to accommodate everything within an OpenAPI spec to create a source of truth for the operational behaviour of your API. Check out the OpenAPI Extension Guide to configure the operational aspects of your API. Available Properties Disabled This boolean property allows you to disable the corresponding path/operation, \"hiding\" internal operations from being published to end users. When set to true at the top level, all paths will be hidden; you will have to override specific paths/operations with disabled: false to make those operations visible. ... /path : x-kusk : disabled : true ... Hosts This string array property configures the hosts (i.e. Host HTTP header) list the Gateway will listen traffic for. Wildcard hosts are supported in the suffix or prefix form, exclusively, i.e.: *.example.org example.* ... x-kusk : hosts : - onehost.com ... Read more in the guide on Routing . CORS The CORS object sets properties for configuring CORS for your API. Name Description cors.origins List of HTTP origins accepted by the configured operations. cors.methods List of HTTP methods accepted by the configured operations. cors.headers List of HTTP headers accepted by the configured operations. cors.expose_headers List of HTTP headers exposed by the configured operations. cors.credentials Boolean flag for requiring credentials. cors.max_age Indicates how long results of a preflight request can be cached. Sample: ... x-kusk : cors : origins : - \"*\" methods : - POST - GET - OPTIONS headers : - Content-Type credentials : true max_age : 86200 ... Read more in the guide on CORS . QoS Options for configuring QoS settings, such as retries and timeouts. Name Description qos.retries Maximum number of retries (0 by default). qos.request_timeout Total request timeout (in seconds). qos.idle_timeout Timeout for idle connections (in seconds). Sample: ... x-kusk : qos : request_timeout : 60 ... Read more in the guide on Timeouts . Websocket An optional boolean field that defines whether to enable handling of \"Upgrade: websocket\" and other actions related to Websocket HTTP headers in the request to create a Websocket tunnel to the backend. The default value is false. Sample: ... x-kusk : websocket : true ... Upstream This setting configures where the traffic goes. service and host are available and are mutually exclusive. The upstream setting is mutually exclusive with redirect setting. service is a reference to a Kubernetes Service inside the cluster, while host can reference any hostname, even outside the cluster. See the guide on Routing to learn more about this functionality. Rewrite Additionally, upstream has an optional object rewrite . This allows modification of the URL of the request before forwarding it to the upstream service. Name Description upstream.rewrite.pattern Regular expression. upstream.rewrite.substitution Regular expression substitution. Sample: ... x-kusk : upstream : service : ... # /foo/bar/... -> to upstream: /bar/... rewrite : pattern : \"^/foo\" substitution : \"\" ... Service The service object sets the target Kubernetes service to receive traffic. It contains the following properties: Name Description namespace The namespace containing the upstream Service. name The upstream Service's name. port The upstream Service's port. Default value is 80. Sample: ... x-kusk : upstream : namespace : default name : svc-name port : 8080 ... Host The host object sets the target host to receive traffic. It contains the following properties: Name Description hostname The hostname to route traffic to. port The target port to route traffic to. Note: service and host are mutually exclusive since they define the same thing (the upstream host to route to). Sample: ... x-kusk : upstream : hostname : domain port : 80 ... Path The path object contains the following properties to configure service endpoints paths: Name Description path.prefix Prefix for the route ( i.e. /your-prefix/here/rest/of/the/route ). Default value is \"/\". If the upstream.rewrite option is not specified, the upstream service will receive the request \"as is\" with this prefix still appended to the URL. If the upstream application doesn't know about this path, usually 404 is returned. Sample: ... x-kusk : path : prefix : /v1 ... See the guide on Routing to learn more about this functionality. Redirect Configures where to redirect the request. The redirect and upstream options are mutually exclusive. Name Description redirect.scheme_redirect Redirect scheme (http/https). redirect.host_redirect Host to redirect to. redirect.port_redirect Port to redirect to. redirect.path_redirect Path to redirect to. redirect.rewrite_regex.pattern Regular expression (mutually exclusive with path_redirect). redirect.rewrite_regex.substitution Regular expression substitution. redirect.strip_query Boolean, configures whether to strip the query from the URL (default false). redirect.response_code Redirect response code (301, 302, 303, 307, 308). Sample: ... x-kusk : redirect : scheme_redirect : https host_redirect : thenewhost.com response_code : 302 ... See the guide on Routing to learn more about this functionality. Validation The validation objects contain the following properties to configure automatic request validation: Name Description validation.request.enabled Boolean flag to enable request validation. See the guide on Validation to learn more about this functionality. Note: Currently, mocking is incompatible with the validation option - the configuration deployment will fail if both are enabled. Sample: ... x-kusk : validation : request : enabled : true ... Mocking The validation objects contain the following properties to configure automatic request validation: Name Description mocking.enabled Boolean flag to enable mocking. See the guide on Mocking to learn more about this functionality. Note: Currently mocking is incompatible with the validation option - the configuration deployment will fail if both are enabled. Sample: ... x-kusk : mocking : enabled : true ... Rate limiting The rate_limit object contains the following properties to configure request rate limiting: Name Description rate_limit.requests_per_unit How many requests API can handle per unit of time. rate_limit.unit Unit of time, can be one of the following: second, minute, hour . rate_limit.per_connection Boolean flag, that specifies whether the rate limiting, should be applied per connection or in total. Default: false. rate_limit.response_code HTTP response code, which is returned when rate limiting. Default: 429, Too Many Requests. Note: Currently, rate limiting is applied per Envoy pod - if you have more than a single Envoy pod the total request capacity will be bigger than specified in the rate_limit object. You can check how many Envoy pods you run in the spec.size attribute of EnvoyFleet object . Sample: ... x-kusk : rate_limit : requests_per_limit : 2 rate_limit.unit : minute ... Caching The cache object contains the following properties to configure HTTP caching: Name Description cache.enabled Boolean flag to enable request validation. cache.max_age Indicates how long (in seconds) results of a request can be cached. Note: current support for caching is experimental. Check out https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/cache_filter to learn more about how it works. Sample: ... x-kusk : cache : enabled : true max_age : 60 ... Authentication The auth object contains the following properties to configure HTTP authentication: Name Description auth.scheme Required . The authentication scheme. Only basic authentication is supported at the moment. auth.path_prefix Optional . The prefix to attach to auth-upstream.host.hostname auth.auth-upstream Required . Defines the upstream authentication host. auth.auth-upstream.host Required . Defines how to reach the authentication server. auth.auth-upstream.host.hostname Required . Defines the hostname the authentication server is running on. auth.auth-upstream.host.port Required . Defines the port the authentication server is running on, for the given auth-upstream.host.hostname . Sample: ... x-kusk : ... auth : scheme : basic path_prefix : /login # optional auth-upstream : host : hostname : example.com port : 80 ... Exposing OpenAPI defintion The openapi-path field takes the a path name and will expose your OpenAPI defintion in defined path. Sample: ... x-kusk : openapi-path : openapi.json ... This will expose your entire OpenAPI defintion, without the Kusk extensions, on yourdomain.com/openapi.json . To remove some paths or operations from the exposed OpenAPI, use the disabled option .","title":"OpenAPI Extension"},{"location":"reference/extension/#openapi-extension-reference","text":"Kusk Gateway comes with an OpenAPI extension to accommodate everything within an OpenAPI spec to create a source of truth for the operational behaviour of your API. Check out the OpenAPI Extension Guide to configure the operational aspects of your API.","title":"OpenAPI Extension Reference"},{"location":"reference/extension/#available-properties","text":"","title":"Available Properties"},{"location":"reference/extension/#disabled","text":"This boolean property allows you to disable the corresponding path/operation, \"hiding\" internal operations from being published to end users. When set to true at the top level, all paths will be hidden; you will have to override specific paths/operations with disabled: false to make those operations visible. ... /path : x-kusk : disabled : true ...","title":"Disabled"},{"location":"reference/extension/#hosts","text":"This string array property configures the hosts (i.e. Host HTTP header) list the Gateway will listen traffic for. Wildcard hosts are supported in the suffix or prefix form, exclusively, i.e.: *.example.org example.* ... x-kusk : hosts : - onehost.com ... Read more in the guide on Routing .","title":"Hosts"},{"location":"reference/extension/#cors","text":"The CORS object sets properties for configuring CORS for your API. Name Description cors.origins List of HTTP origins accepted by the configured operations. cors.methods List of HTTP methods accepted by the configured operations. cors.headers List of HTTP headers accepted by the configured operations. cors.expose_headers List of HTTP headers exposed by the configured operations. cors.credentials Boolean flag for requiring credentials. cors.max_age Indicates how long results of a preflight request can be cached. Sample: ... x-kusk : cors : origins : - \"*\" methods : - POST - GET - OPTIONS headers : - Content-Type credentials : true max_age : 86200 ... Read more in the guide on CORS .","title":"CORS"},{"location":"reference/extension/#qos","text":"Options for configuring QoS settings, such as retries and timeouts. Name Description qos.retries Maximum number of retries (0 by default). qos.request_timeout Total request timeout (in seconds). qos.idle_timeout Timeout for idle connections (in seconds). Sample: ... x-kusk : qos : request_timeout : 60 ... Read more in the guide on Timeouts .","title":"QoS"},{"location":"reference/extension/#websocket","text":"An optional boolean field that defines whether to enable handling of \"Upgrade: websocket\" and other actions related to Websocket HTTP headers in the request to create a Websocket tunnel to the backend. The default value is false. Sample: ... x-kusk : websocket : true ...","title":"Websocket"},{"location":"reference/extension/#upstream","text":"This setting configures where the traffic goes. service and host are available and are mutually exclusive. The upstream setting is mutually exclusive with redirect setting. service is a reference to a Kubernetes Service inside the cluster, while host can reference any hostname, even outside the cluster. See the guide on Routing to learn more about this functionality.","title":"Upstream"},{"location":"reference/extension/#rewrite","text":"Additionally, upstream has an optional object rewrite . This allows modification of the URL of the request before forwarding it to the upstream service. Name Description upstream.rewrite.pattern Regular expression. upstream.rewrite.substitution Regular expression substitution. Sample: ... x-kusk : upstream : service : ... # /foo/bar/... -> to upstream: /bar/... rewrite : pattern : \"^/foo\" substitution : \"\" ...","title":"Rewrite"},{"location":"reference/extension/#service","text":"The service object sets the target Kubernetes service to receive traffic. It contains the following properties: Name Description namespace The namespace containing the upstream Service. name The upstream Service's name. port The upstream Service's port. Default value is 80. Sample: ... x-kusk : upstream : namespace : default name : svc-name port : 8080 ...","title":"Service"},{"location":"reference/extension/#host","text":"The host object sets the target host to receive traffic. It contains the following properties: Name Description hostname The hostname to route traffic to. port The target port to route traffic to. Note: service and host are mutually exclusive since they define the same thing (the upstream host to route to). Sample: ... x-kusk : upstream : hostname : domain port : 80 ...","title":"Host"},{"location":"reference/extension/#path","text":"The path object contains the following properties to configure service endpoints paths: Name Description path.prefix Prefix for the route ( i.e. /your-prefix/here/rest/of/the/route ). Default value is \"/\". If the upstream.rewrite option is not specified, the upstream service will receive the request \"as is\" with this prefix still appended to the URL. If the upstream application doesn't know about this path, usually 404 is returned. Sample: ... x-kusk : path : prefix : /v1 ... See the guide on Routing to learn more about this functionality.","title":"Path"},{"location":"reference/extension/#redirect","text":"Configures where to redirect the request. The redirect and upstream options are mutually exclusive. Name Description redirect.scheme_redirect Redirect scheme (http/https). redirect.host_redirect Host to redirect to. redirect.port_redirect Port to redirect to. redirect.path_redirect Path to redirect to. redirect.rewrite_regex.pattern Regular expression (mutually exclusive with path_redirect). redirect.rewrite_regex.substitution Regular expression substitution. redirect.strip_query Boolean, configures whether to strip the query from the URL (default false). redirect.response_code Redirect response code (301, 302, 303, 307, 308). Sample: ... x-kusk : redirect : scheme_redirect : https host_redirect : thenewhost.com response_code : 302 ... See the guide on Routing to learn more about this functionality.","title":"Redirect"},{"location":"reference/extension/#validation","text":"The validation objects contain the following properties to configure automatic request validation: Name Description validation.request.enabled Boolean flag to enable request validation. See the guide on Validation to learn more about this functionality. Note: Currently, mocking is incompatible with the validation option - the configuration deployment will fail if both are enabled. Sample: ... x-kusk : validation : request : enabled : true ...","title":"Validation"},{"location":"reference/extension/#mocking","text":"The validation objects contain the following properties to configure automatic request validation: Name Description mocking.enabled Boolean flag to enable mocking. See the guide on Mocking to learn more about this functionality. Note: Currently mocking is incompatible with the validation option - the configuration deployment will fail if both are enabled. Sample: ... x-kusk : mocking : enabled : true ...","title":"Mocking"},{"location":"reference/extension/#rate-limiting","text":"The rate_limit object contains the following properties to configure request rate limiting: Name Description rate_limit.requests_per_unit How many requests API can handle per unit of time. rate_limit.unit Unit of time, can be one of the following: second, minute, hour . rate_limit.per_connection Boolean flag, that specifies whether the rate limiting, should be applied per connection or in total. Default: false. rate_limit.response_code HTTP response code, which is returned when rate limiting. Default: 429, Too Many Requests. Note: Currently, rate limiting is applied per Envoy pod - if you have more than a single Envoy pod the total request capacity will be bigger than specified in the rate_limit object. You can check how many Envoy pods you run in the spec.size attribute of EnvoyFleet object . Sample: ... x-kusk : rate_limit : requests_per_limit : 2 rate_limit.unit : minute ...","title":"Rate limiting"},{"location":"reference/extension/#caching","text":"The cache object contains the following properties to configure HTTP caching: Name Description cache.enabled Boolean flag to enable request validation. cache.max_age Indicates how long (in seconds) results of a request can be cached. Note: current support for caching is experimental. Check out https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/cache_filter to learn more about how it works. Sample: ... x-kusk : cache : enabled : true max_age : 60 ...","title":"Caching"},{"location":"reference/extension/#authentication","text":"The auth object contains the following properties to configure HTTP authentication: Name Description auth.scheme Required . The authentication scheme. Only basic authentication is supported at the moment. auth.path_prefix Optional . The prefix to attach to auth-upstream.host.hostname auth.auth-upstream Required . Defines the upstream authentication host. auth.auth-upstream.host Required . Defines how to reach the authentication server. auth.auth-upstream.host.hostname Required . Defines the hostname the authentication server is running on. auth.auth-upstream.host.port Required . Defines the port the authentication server is running on, for the given auth-upstream.host.hostname . Sample: ... x-kusk : ... auth : scheme : basic path_prefix : /login # optional auth-upstream : host : hostname : example.com port : 80 ...","title":"Authentication"},{"location":"reference/extension/#exposing-openapi-defintion","text":"The openapi-path field takes the a path name and will expose your OpenAPI defintion in defined path. Sample: ... x-kusk : openapi-path : openapi.json ... This will expose your entire OpenAPI defintion, without the Kusk extensions, on yourdomain.com/openapi.json . To remove some paths or operations from the exposed OpenAPI, use the disabled option .","title":"Exposing OpenAPI defintion"},{"location":"reference/openapi/","text":"Dashboard API See the API currently exposed by the Kusk Gateway API Server to the Kusk Dashboard below. Feel free to integrate with this API as needed for your Kusk Gateway automation/configuration needs! SwaggerUIBundle({ url: 'https://raw.githubusercontent.com/kubeshop/kuskgateway-api-server/main/api/openapi.yaml', dom_id: '#swagger-ui', })","title":"Dashboard API"},{"location":"reference/openapi/#dashboard-api","text":"See the API currently exposed by the Kusk Gateway API Server to the Kusk Dashboard below. Feel free to integrate with this API as needed for your Kusk Gateway automation/configuration needs! SwaggerUIBundle({ url: 'https://raw.githubusercontent.com/kubeshop/kuskgateway-api-server/main/api/openapi.yaml', dom_id: '#swagger-ui', })","title":"Dashboard API"}]}