"use strict";(self.webpackChunkkusk_gateway_docs_2=self.webpackChunkkusk_gateway_docs_2||[]).push([[366],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=p(n),d=o,m=h["".concat(l,".").concat(d)]||h[d]||u[d]||a;return n?r.createElement(m,i(i({ref:t},c),{},{components:n})):r.createElement(m,i({ref:t},c))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<a;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},14570:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var r=n(87462),o=(n(67294),n(3905));const a={},i="Static Route",s={unversionedId:"reference/customresources/staticroute",id:"reference/customresources/staticroute",title:"Static Route",description:"This resource defines manually created routing rules. It is useful to set up the routing to a non-API application, e.g. static pages or images or to route to legacy, possibly external to the cluster, APIs.",source:"@site/docs/reference/customresources/staticroute.md",sourceDirName:"reference/customresources",slug:"/reference/customresources/staticroute",permalink:"/reference/customresources/staticroute",draft:!1,editUrl:"https://github.com/kubeshop/kusk-gateway/docs/reference/customresources/staticroute.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Envoy Fleet",permalink:"/reference/customresources/envoyfleet"},next:{title:"How to Develop Kusk Gateway",permalink:"/contributing"}},l={},p=[{value:"<strong>Limitations</strong>",id:"limitations",level:2},{value:"<strong>Configuration Structure Description</strong>",id:"configuration-structure-description",level:2},{value:"<strong>Envoy Fleet</strong>",id:"envoy-fleet",level:2},{value:"<strong>Request Matching</strong>",id:"request-matching",level:2},{value:"<strong>Final Action on the Matched Request</strong>",id:"final-action-on-the-matched-request",level:2},{value:"<strong>Redirect</strong>",id:"redirect",level:3},{value:"<strong>Route</strong>",id:"route",level:3},{value:"<strong>Example</strong>",id:"example",level:2}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"static-route"},"Static Route"),(0,o.kt)("p",null,"This resource defines manually created routing rules. It is useful to set up the routing to a non-API application, e.g. static pages or images or to route to legacy, possibly external to the cluster, APIs."),(0,o.kt)("p",null,'The Static Route resource is designed to overcome the shortcomings of OpenAPI based routing, one of which is the inability to configure "catch all prefixes" like ',(0,o.kt)("strong",{parentName:"p"},"/"),".\nIts structure is still similar to OpenAPI and, thus, familiar to users."),(0,o.kt)("p",null,"The resource can be deployed to the API resource or completely separately. Routing information from both resources will be merged with the priority given to the ",(0,o.kt)("strong",{parentName:"p"},"API")," resources."),(0,o.kt)("p",null,"Once the resource manifest is deployed, Kusk Gateway Manager will use it to configure routing for Envoy Fleet.\nMultiple resources can exist in different namespaces, all of them will be evaluated and the configuration merged on any action with the separate resource.\nTrying to apply a resource that has conflicting routes with the existing resources (i.e. same HTTP method and path) will be rejected with the error."),(0,o.kt)("h2",{id:"limitations"},(0,o.kt)("strong",{parentName:"h2"},"Limitations")),(0,o.kt)("p",null,"Currently, the resource ",(0,o.kt)("strong",{parentName:"p"},"status")," field is not updated by the manager when the reconciliation of the configuration finishes."),(0,o.kt)("h2",{id:"configuration-structure-description"},(0,o.kt)("strong",{parentName:"h2"},"Configuration Structure Description")),(0,o.kt)("p",null,"The main elements of the configuration are in the ",(0,o.kt)("strong",{parentName:"p"},"spec")," field."),(0,o.kt)("p",null,"The elements specify how the incoming request is matched and what action to take."),(0,o.kt)("p",null,"Below is the YAML structure of the configuration. Please read further for a full explanation."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: gateway.kusk.io/v1alpha1\nkind: StaticRoute\nmetadata:\n  name: staticroute-sample\nspec:\n  # Envoy Fleet (its name and namespace) to deploy the configuration to, here - deployed EnvoyFleet with the name "default" in the namespace "default".\n  # Optional, if not specified - single (default) fleet autodetection will be performed in the cluster.\n  fleet:\n    name: default\n    namespace: default\n  hosts: [<string>, <string>, ...]\n  paths:\n    # Consists of path matchers with HTTP methods (lowercase), which in turn either:\n    # 1. "route" (proxying) to the upstream host or\n    # 2. "redirect" to other endpoint\n    <path_match>:\n      <http_method>:\n        # "route" defines proxying parameters. Mutually exclusive with "redirect".\n        route:\n          # upstream is the container for the upstream host specification.\n          upstream:\n            # host defines the hostname to proxy to. Mutually exclusive with service.\n            host:\n              # DNS name to proxy to\n              hostname: <string>\n              # Port to proxy to\n              port: <int>\n            # service is the convenient way to configure proxying to Kubernetes services. Mutually exclusive with the "host".\n            service:\n              # service name\n              name: <string>\n              namespace: <string>\n              port: 8080\n            # rewrites path with the regex and substitution patterns. \n            rewrite:\n              pattern: <string> # path regex pattern\n              substitution: <string> # path substitution pattern.\n          # Optional\n          qos:\n            # the timeout for the upstream connection, seconds. 0 means forever, if unspecified - 15 seconds.\n            request_timeout: <int>\n            # the timeout for the idle upstream of downstream connection, seconds. 0 means forever, unspecified default 1h.\n            idle_timeout: <int>\n            # retries define how many retries to upstream with failed (50x code) requests, number. Default 1.\n            retries: <int>\n          # Optional\n          cors:\n            # allowed origins returned in Access-Control-Allow-Origin header\n            # the list of domain names\n            # Note - regex other than the wildcard ("*") are not supported right now.\n            origins:\n            - "*"\n            # allowed methods to call this endpoint returned in Access-Control-Allow-Methods header\n            # the list of methods\n            methods:\n            - POST\n            - GET\n            # allowed headers returned in Access-Control-Allow-Headers header\n            # the list of headers\n            headers:\n            - Content-Type\n            # allow browser to send credentials, returned with Access-Control-Allow-Credentials header\n            credentials: <true|false>\n            # allowed headers that browser can access returned with  Access-Control-Expose-Headers header\n            # the list of headers\n            expose_headers:\n            - X-Custom-Header1\n            - X-Custom-Header2\n            # how long to cache this CORS information for the browser, returned with Access-Control-Max-Age.\n            max_age: <int>\n          # Enable establishing Websockets connections\n          websocket: <true|false>\n        # "redirect" creates HTTP redirect to other endpoint. Mutually exclusive with "route".\n        redirect:\n          # redirect to http or https\n          scheme_redirect: <http|https>\n          # redirect to this hostname\n          host_redirect: <string>\n          # redirects to different port\n          port_redirect: <int>\n          # redirect to different URL path. Mutually exclusive with rewrite_regex.\n          path_redirect: "<string>"\n          # redirect using the rewrite rule. Mutually exclusive with path_redirect.\n          rewrite_regex:\n            # regex\n            pattern: <string>\n            # regex parameters substitution pattern\n            substitution: <string>\n          # response code, by default - Permanent Redirect HTTP 308\n          # available HTTP codes: 301, 302, 303, 307, 308\n          response_code: <int>\n      <http_method>:\n        -- skipped --\n')),(0,o.kt)("h2",{id:"envoy-fleet"},(0,o.kt)("strong",{parentName:"h2"},"Envoy Fleet")),(0,o.kt)("p",null,"The spec.",(0,o.kt)("strong",{parentName:"p"},"fleet")," optional field specifies to which Envoy Fleet (Envoy Proxy instances with the exposing K8s Service) this configuration applies.\nfleet.",(0,o.kt)("strong",{parentName:"p"},"name")," and fleet.",(0,o.kt)("strong",{parentName:"p"},"namespace")," reference the deployed Envoy Fleet Custom Resource name and namespace."),(0,o.kt)("p",null,"You can deploy a Static Route configuration in any namespace with any name and it will be applied to the specific Envoy Fleet.\nIf this option is missing, the autodetection will be performed to find the single fleet deployed in the Kubernetes cluster Fleet, which is then considered as the default Fleet.\nThe deployed Static Route custom resource will be changed to map to that fleet accordingly.\nIf there are multiple fleets deployed, spec.",(0,o.kt)("strong",{parentName:"p"},"fleet")," is required to specify which in the manifest."),(0,o.kt)("h2",{id:"request-matching"},(0,o.kt)("strong",{parentName:"h2"},"Request Matching")),(0,o.kt)("p",null,"We match the incoming request by HOST header, path and HTTP method."),(0,o.kt)("p",null,"The following fields specify matching:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"hosts")," - Defines the list of HOST headers to which the current configuration applies. This will create the Envoy's VirtualHost with the same name and domain matching. Wildcards are possible, e.g. \"",(0,o.kt)("em",{parentName:"p"},'" means "any host".\nPrefix and suffix wildcards are supported, but not both (i.e. ```example.'),", ",(0,o.kt)("em",{parentName:"p"},"example.com",(0,o.kt)("inlineCode",{parentName:"em"},", but not ")),"example*```)."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"paths")," - The container of URL paths and HTTP methods collection to match and handle the request during the routing decision.\n",(0,o.kt)("em",{parentName:"p"},"paths"),".",(0,o.kt)("strong",{parentName:"p"},"path_match")," is the URL path string and starts with / (e.g. ",(0,o.kt)("em",{parentName:"p"},"/api"),", ",(0,o.kt)("em",{parentName:"p"},"/robots.txt"),"). The suffix hints how to match the request:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Paths ending with ",(0,o.kt)("inlineCode",{parentName:"li"},"/")," will match everything that has that path as a prefix. E.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"/api/")," matches ",(0,o.kt)("inlineCode",{parentName:"li"},"/api/v1/id"),", just ",(0,o.kt)("inlineCode",{parentName:"li"},"/")," is a catch all."),(0,o.kt)("li",{parentName:"ul"},"Paths without ",(0,o.kt)("inlineCode",{parentName:"li"},"/")," will match that path exactly. For example, ",(0,o.kt)("inlineCode",{parentName:"li"},"/resource")," matches exactly this resource with any possible URL query.  ",(0,o.kt)("strong",{parentName:"li"},"Alpha limitations:")," Regexes are currently not supported.")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"paths"),".",(0,o.kt)("em",{parentName:"p"},"path_match"),".",(0,o.kt)("strong",{parentName:"p"},"http_method"),' - Adds an additional request matcher which is the lowercase HTTP method (get, post, ...). Calls to the paths with a method not set here will return "404 Not Found".'),(0,o.kt)("h2",{id:"final-action-on-the-matched-request"},(0,o.kt)("strong",{parentName:"h2"},"Final Action on the Matched Request")),(0,o.kt)("p",null,"Once the request is matched, we can decide what to do with it."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"paths"),".",(0,o.kt)("em",{parentName:"p"},"path_match"),".http_method_match.",(0,o.kt)("strong",{parentName:"p"},"route|redirect")," specifies the routing decision. The request can be either proxied to the upstream host (backend) or returned to the user as a redirect. Either ",(0,o.kt)("a",{parentName:"p",href:"#redirect"},(0,o.kt)("strong",{parentName:"a"},"redirect"))," or ",(0,o.kt)("a",{parentName:"p",href:"#route"},(0,o.kt)("strong",{parentName:"a"},"route"))," must be specified, but not both."),(0,o.kt)("p",null," ",(0,o.kt)("strong",{parentName:"p"},"Alpha Limitations:")," Currently additional request handling (e.g. direct request response like returning 404 Not Found) is not implemented."),(0,o.kt)("h3",{id:"redirect"},(0,o.kt)("strong",{parentName:"h3"},"Redirect")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"redirect")," provides HTTP redirect options with the following fields. All of them are optional but, once specified, enable a part of redirection behaviour."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"redirect")," structure:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"\nredirect:\n  scheme_redirect: <http|https> # redirect to http or https.\n  host_redirect: <string> # redirect to this hostname.\n  port_redirect: <string> # redirect to this port.\n  path_redirect: <string> # redirect to this path, old path is removed. Mutually exclusive with rewrite_regex.\n  rewrite_regex: # redirect to this rewritten with regex path. Mutually exclusive with path_redirect.\n   pattern: <string> # path regex pattern\n   substitution: <string> # path substitution pattern.\n  response_code: # redirect HTTP response code to return to the user. Available HTTP codes: 301, 302, 303, 307, 308\n  strip_query: <bool> # strip path query during redirect, default false.\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"rewrite_regex")," pattern matching and substitution provides a powerful mechanism to rewrite redirect path based on incoming requests.\nFrom Envoy's documentation:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Indicates that during redirect, portions of the path that match the pattern should be rewritten, even allowing the substitution of capture groups from the pattern into the new path as specified by the rewrite substitution string. This is useful to allow application paths to be rewritten in a way that is aware of segments with variable content like identifiers.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Examples using Google\u2019s RE2 engine:")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"   The path pattern ^/service/(",(0,o.kt)("sup",{parentName:"p",id:"fnref-/"},(0,o.kt)("a",{parentName:"sup",href:"#fn-/",className:"footnote-ref"},"/")),"+)(/.*)$ paired with a substitution string of \\2/instance/\\1 would transform /service/foo/v1/api into /v1/api/instance/foo."),(0,o.kt)("p",{parentName:"blockquote"},"   The pattern one paired with a substitution string of two would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/two/zzz."),(0,o.kt)("p",{parentName:"blockquote"},"   The pattern ^(.",(0,o.kt)("em",{parentName:"p"},"?)one(."),")$ paired with a substitution string of \\1two\\2 would replace only the first occurrence of one, transforming path /xxx/one/yyy/one/zzz into /xxx/two/yyy/one/zzz."),(0,o.kt)("p",{parentName:"blockquote"},"   The pattern (?i)/xxx/ paired with a substitution string of /yyy/ would do a case-insensitive match and transform path /aaa/XxX/bbb to /aaa/yyy/bbb.")),(0,o.kt)("h3",{id:"route"},(0,o.kt)("strong",{parentName:"h3"},"Route")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"route")," specifies how the request will be proxied to the upstream with the following fields:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"route")," structure:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'route:\n  # upstream is the container for the upstream host specification. Either upstream.host or upstream.service must be specified.\n  upstream:\n    # host defines the hostname to proxy to. Mutually exclusive with service.\n    host:\n      # DNS hostname to proxy to\n      hostname: <string>\n      # host port\n      port: <int>\n    # service is the convenient way to configure proxying to Kubernetes services. Mutually exclusive with the "host".\n    service:\n      # K8s service name to proxy to\n      name: <string>\n      # service namespace\n      namespace: <string>\n      # service port\n      port: <int>\n    # rewrites path with the regex and substitution patterns. \n    rewrite:\n      pattern: <string> # path regex pattern\n      substitution: <string> # path substitution pattern.\n  # Quality of Service for the request\n  # Optional\n  qos:\n    # the timeout for the upstream connection, seconds. 0 means forever, if unspecified - 15 seconds.\n    request_timeout: <int>\n    # the timeout for the idle upstream of downstream connection, seconds. 0 means forever, unspecified default 1h.\n    idle_timeout: <int>\n    # retries define how many retries to upstream with failed (50x code) requests, number. Default 1.\n    retries: <int>\n  # Optional\n  cors:\n    # allowed origins returned in Access-Control-Allow-Origin header\n    # the list of domain names\n    # Note - regex other than the wildcard ("*") are not supported right now.\n    # WARNING - this is just the example, write your own CORS settings.\n    origins:\n    - "*"\n    # allowed methods to call this endpoint returned in Access-Control-Allow-Methods header\n    # the list of methods\n    methods:\n    - POST\n    - GET\n    # allowed headers returned in Access-Control-Allow-Headers header\n    # the list of headers\n    headers:\n    - Content-Type\n    # allow browser to send credentials, returned with Access-Control-Allow-Credentials header\n    credentials: <true|false>\n    # allowed headers that browser can access returned with  Access-Control-Expose-Headers header\n    # the list of headers\n    expose_headers:\n    - X-Custom-Header1\n    - X-Custom-Header2\n    # how long to cache this CORS information for the browser in seconds, returned with Access-Control-Max-Age header\n    max_age: <int>\n  # Enable establishing Websockets connections\n  websocket: <true|false>\n\n')),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"route"),".",(0,o.kt)("strong",{parentName:"p"},"upstream")," - A required field that defines the upstream host parameters.\nWe proxy using DNS hostname or local cluster K8s service parameters, which are further resolved to DNS hostname. Either ",(0,o.kt)("em",{parentName:"p"},"upstream"),".",(0,o.kt)("strong",{parentName:"p"},"host")," or ",(0,o.kt)("em",{parentName:"p"},"upstream"),".",(0,o.kt)("strong",{parentName:"p"},"service")," must be specified inside."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"route"),".",(0,o.kt)("strong",{parentName:"p"},"upstream"),".",(0,o.kt)("strong",{parentName:"p"},"rewrite")," - An optional field that specifies what to do with the URL path when proxying to the upstream. The only value currently is ",(0,o.kt)("strong",{parentName:"p"},"rewrite"),". See the rewrite_regex section in redirect action above for the explanation."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"route"),".",(0,o.kt)("strong",{parentName:"p"},"qos")," - An optional field that is the container for request Quality of Service parameters, i.e. timeouts, failure retry policy."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"route"),".",(0,o.kt)("strong",{parentName:"p"},"cors")," - An optional field that is the container for ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Cross-origin_resource_sharing"},"Cross-Origin Resource Sharing")," headers parameters. If this field is specified, the route will be augmented with CORS preflight OPTIONS HTTP method matching. This will allow Envoy to return the response to the OPTIONS request with the specified CORS headers to the user without proxying to upstream. It is advised to read ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS"},"CORS")," before trying to configure this."),(0,o.kt)("p",null,"Note: The structure for CORS specified above is an example; users should write their own set of methods and headers."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"route"),".",(0,o.kt)("strong",{parentName:"p"},"websocket"),' - An optional boolean field that defines whether to enable handling of "Upgrade: websocket" and related Websocket HTTP headers in the request to create a Websocket tunnel to the backend. The default is false - don\'t handle Websockets.'),(0,o.kt)("h2",{id:"example"},(0,o.kt)("strong",{parentName:"h2"},"Example")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: gateway.kusk.io/v1alpha1\nkind: StaticRoute\nmetadata:\n  name: sample\nspec:\n  # should work with localhost, example.org, any host\n  hosts: [ "localhost", "*"]\n  paths:\n    # Catch all prefix /\n    /: \n      # HTTP method GET\n      get:\n        route: &root_route # here we\'re using YAML anchors to decrease the boilerplate for all HTTP methods - the configuration is the same.\n          upstream:\n            host:\n              # DNS name to proxy forward to\n              hostname: front.somehostname.com\n              # Port to proxy to\n              port: 80\n      post: *root_route\n      put: *root_route\n      head: *root_route\n      patch: *root_route\n    # robots.txt is served by the new frontend. Here we use "host" to show that it can replace "service" safely.\n    /robots.txt: \n      get:\n        route:\n          upstream:\n            host:\n              hostname: front.frontapps.svc.cluster.local.\n              port: 80\n    # GET to /oldstatic resource redirects to /static\n    /oldstatic/: \n      get:\n        redirect:\n          # redirect to different path /oldstatic/blabla -> /static/blabla\n          rewrite_regex:\n            pattern: \'/oldstatic/(.*)\'\n            substitution: \'/static/\\1\'\n          response_code: 308\n    /static/:\n      get:\n        route:\n          upstream:\n            service:\n              name: "front"\n              namespace: "frontapps"\n              port: 80\n    # GET to /images/ is proxied to K8s service images in images namespace\n    /images/: \n      get:\n        route: \n          upstream:\n            service:\n              name: images\n              namespace: images\n              port: 8080\n    # old API is served on other path with the rewrite of path to upstream\n    /api/v0/:\n      get:\n        route: &old_api_route\n          upstream:\n            service:\n              name: api0\n              namespace: legacy\n              port: 80\n            # removes /api/v0 from the path when proxying to upstream\n            rewrite:\n              pattern: "^/api/v0"\n              substitution: ""\n          # Old API is slow and unreliable\n          qos:\n            request_timeout: 30\n            idle_timeout: 60\n            retries: 5\n          cors:\n            origins:\n            - "*"\n            methods:\n            - GET\n            - POST\n            - PUT\n            - PATCH\n            - HEAD\n            headers:\n            - Content-Type\n            - Content-Encoding\n            credentials: false\n            expose_headers:\n            - X-API-VERSION\n            max_age: 8600\n          websocket: true\n      post: *old_api_route\n      put: *old_api_route\n      patch: *old_api_route\n      head: *old_api_route\n')))}u.isMDXComponent=!0}}]);