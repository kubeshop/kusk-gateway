"use strict";(self.webpackChunkkusk_gateway_docs_2=self.webpackChunkkusk_gateway_docs_2||[]).push([[6415],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),f=p(n),m=i,d=f["".concat(l,".").concat(m)]||f[m]||u[m]||a;return n?r.createElement(d,s(s({ref:t},c),{},{components:n})):r.createElement(d,s({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,s=new Array(a);s[0]=f;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var p=2;p<a;p++)s[p]=n[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},61051:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>p});var r=n(87462),i=(n(67294),n(3905));const a={},s="Traffic splitting",o={unversionedId:"guides/traffic_splitting",id:"guides/traffic_splitting",title:"Traffic splitting",description:"Traffic splitting in Kusk allows for traffic to be routed to 2 or more targets for the same API. The traffic to the API or API path will be split between services running different version of the same service.",source:"@site/docs/guides/traffic_splitting.md",sourceDirName:"guides",slug:"/guides/traffic_splitting",permalink:"/guides/traffic_splitting",draft:!1,editUrl:"https://github.com/kubeshop/kusk-gateway/docs/guides/traffic_splitting.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"CORS Settings",permalink:"/guides/cors"},next:{title:"Response Mocking",permalink:"/guides/mocking"}},l={},p=[{value:"How does Traffic splitting work?",id:"how-does-traffic-splitting-work",level:2}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"traffic-splitting"},"Traffic splitting"),(0,i.kt)("p",null,"Traffic splitting in Kusk allows for traffic to be routed to 2 or more targets for the same API. The traffic to the API or API path will be split between services running different version of the same service."),(0,i.kt)("h2",{id:"how-does-traffic-splitting-work"},"How does Traffic splitting work?"),(0,i.kt)("p",null,"Setting property ",(0,i.kt)("inlineCode",{parentName:"p"},"x-kusk.upstreams")," allows users to configure several endpoints for the API to which traffic will be split according to the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"service.weight"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"openapi: 3.0.0\ninfo:\n  title: simple-api\n  version: 0.1.0\nx-kusk:\n  upstreams:\n    service:\n      name: simple-api-servicev1\n      namespace: default\n      port: 80\n      weight: 50\n    service:    \n      name: simple-api-servicev2\n      namespace: test-namespace\n      port: 80\n      weight: 50\n..\n")),(0,i.kt)("p",null,"The sum of the weights must be equal to 100. In this example traffic will be split equaly between services. Any number of services can be used as long the total weight equals to 100. "),(0,i.kt)("p",null,"To debug easily Kusk will set response header ",(0,i.kt)("inlineCode",{parentName:"p"},"x-kusk-weighted-cluster:[service_name]")," for each weighted service. "),(0,i.kt)("p",null,"The property ",(0,i.kt)("inlineCode",{parentName:"p"},"x-kusk.upstreams")," is mutually exclusive with ",(0,i.kt)("inlineCode",{parentName:"p"},"x-kusk.upstream")," as well with ",(0,i.kt)("inlineCode",{parentName:"p"},"x-kusk.validation")," will not accept multiple upstreams. "),(0,i.kt)("p",null,"Upstreams can be combination ",(0,i.kt)("inlineCode",{parentName:"p"},"service")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"host")," where each must have weight value assinged."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"openapi: 3.0.0\ninfo:\n  title: simple-api\n  version: 0.1.0\nx-kusk:\n  upstreams:\n    service:\n      name: simple-api-servicev1\n      namespace: default\n      port: 80\n      weight: 50\n    host:    \n      hostname: simple-api-servicev2\n      port: 80\n      weight: 50\n..\n")))}u.isMDXComponent=!0}}]);